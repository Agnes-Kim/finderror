169. bug report number : ['5002']
comment number: 57178404 
body: Bah, I'm wrong, something else is wrong after upgrading protobuf....

(turns out: I needed to re-run configure to get the path to the correct version of protobuf headers)
 

170. bug report number : ['4942']
comment number: 56031400 
body: Are you sure this fixes the problem with peers.dat? StartNode() is still starting the DumpAddresses()-thread and inside that function there is still no check, like the one I proposed in #4784.
 

comment number: 56031857 
body: StartNode is not called in the case that there is a lock file, as AppInit2 stops partway!
 

comment number: 56032946 
body: @laanwj If StartNode() get's called we start the thread for `DumpAddresses()`, right? So we end up in the same situation in a case where the client is running for `DUMP_ADDRESSES_INTERVAL * 1000`, if addrman has 0 addresses.
 

comment number: 56033238 
body: _IF_ StartNode() was called, it is valid for the shutdown (or the DumpAddresses thread) to write the addresses file, no matter how many addresses are in it.

This is an initialization sequence fix: It makes sure that if the lock file is missing, or AppInit2() exits in some other way before addresses list is initialized, it won't write an empty file on shutdown (and StopNode),
 

comment number: 56033643 
body: Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4942_94064710b9123dfb3df8cfd6c32efae349aec281/ for binaries and test log.
This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/
Contact BlueMatt on freenode if something looks broken.
 

comment number: 56042264 
body: @laanwj But wouldn't it also make sense to prevent overwriting with 0 addresses, even if the init stage was processed correctly?
 

comment number: 56042505 
body: @Diapolo Writing 0 addresses is fine in principle. It's only an error if the previous addresses weren't read, or we're not allowed to write to the data directory at all.
 

comment number: 57572241 
body: utACK. I guess at some point we want the fee data to move from globals into an encapsulated state, which only exists when it was correctly loaded. But this is already an improvement.
 

comment number: 57592565 
body: @sipa Agreed on that, eventually it should be an encapsulated structure that is instantiated/destroyed instead of having code directly in AppInit2()/ShutDown().
 

comment number: 58906238 
body: ut ACK
 

171. bug report number : ['4870']
comment number: 54853233 
body: The bug is that the filter parameter has been forgotten to add in wtx.GetCredit.
Like this

```
-    int64_t GetCredit(bool fUseCache=true) const
+    int64_t GetCredit(const isminefilter& filter) const
```

The variable nWatchCreditCached is even defined in constructor, but never used.
I have this and some other minor watch-only fixes laying around on my harddrive for a while now.
I will look into submitting the pull request this week.
 

172. bug report number : ['4818']
comment number: 65779357 
body: Can you have a look at this @luke-jr?
 

173. bug report number : ['4756']
comment number: 54612620 
body: This looks like premature optimization to me. But even then, any concrete indication that just generating a string of spaces is slower than copying it? My gut feeling would be that it is faster to generate them, as there is less memory access in that case.

I'd say it would be better to not create a temporary string at all. See #4851.
 

174. bug report number : ['4730']
comment number: 52735178 
body: Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4730_dc271fc025d219c18428a4d36dbc372c8e457908/ for binaries and test log.
This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/
Contact BlueMatt on freenode if something looks broken.
 

comment number: 52854856 
body: ut ACK.
 

175. bug report number : ['4708']
comment number: 52379523 
body: I'm going to guess this is due to 6548cc9f9073bf6602e17f62017af5c0e2bc3457 . Works fine for me on 10.9, must be some subtle built-in difference. Will have a look.
 

comment number: 52381526 
body: I was completely wrong above. The likely reason for the failure (unfortunately) is that these have been broken for a long time but nobody's noticed. The depends builder automatically fetches and configures the comparison tool, so those tests are finally running. #4710 should fix.
 

comment number: 52671096 
body: Fixed.
 

176. bug report number : ['4705']
comment number: 52387451 
body: Looks like the overview is no longer properly aligned to the right
@diapolo could this be caused by #4627 / 94e1b9e ?
 

177. bug report number : ['4682']
comment number: 51877994 
body: Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4682_c5725f14a379ad497c312d5fcb5b39ed95c6817e/ for binaries and test log.
This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/
Contact BlueMatt on freenode if something looks broken.
 

178. bug report number : ['4679']
comment number: 51852407 
body: Google Analytics is client side javascript; they won't be seeing hits in that even if they did use it.
 

comment number: 51870309 
body: http://74.208.43.192/simple/
 

comment number: 51875271 
body: Guess they did notice the hundreds of thousands of nodes bombing them with requests. 
 

comment number: 51877171 
body: See #4682
 

179. bug report number : ['4669']
comment number: 51713236 
body: `DumpAddresses()` is run 15 minutes after starting the node AFAIK. So it shouldn't directly overwrite peers.dat. All seems unrelated to the `.lock` file. That file can be there, if it's locked by another bitcoin process we don't startup another instance. If we crash-reboot that lock is gone and another instance can be started.

Mind explaining it again, perhaps I don't understand. List the exact steps and what happend to get you an empty peers.dat.
 

comment number: 51713879 
body: @Diapolo DumpAddresses() also runs at shutdown.

We can see the following code logic:
- bitcoind.cpp calls AppInit2()
- AppInit2() returns false upon hitting .lock (step 4), and does not read addrman db (step 10).
- bitcoind.cpp calls Shutdown() -> StopNode() -> DumpAddresses()

In fact, we flush several databases we have not read, if .lock is encountered!

Definitely a bug.
 

comment number: 51719035 
body: I can confirm that I experienced this with an un-clean shutdown. Same result with 0 addresses read. 
 

comment number: 56027524 
body: > In fact, we flush several databases we have not read, if .lock is encountered!

I've looked at this in more detail, and it is not as bad as it seems:
- GenerateBitcoins(false) does nothing if GenerateBitcoins(true) was never called
- StopRPCThreads() does nothing if StartRPCThreads() wasn't called (rpc_io_service == NULL)
- pwalletMain: is still 0, so nothing happens with it, and also not bitdb.Flush()
- pblocktree: is still 0, so no Flush() happens with it

However:
- StopNode() should check whether the node was initialized, and do nothing if it wasn't- anologous to StopRPCThreads. Because this doesn't happen, an empty addresses file is written.
- Same for `mempool` fee estimation logic. Because this doesn't happen, an empty fee estimates file is written.
- `boost::filesystem::remove(GetPidFile())` should only be called if we created the PID file in the first place. But more is wrong here, the PID file is _created_ in bitcoind.cpp far before the datadir lock is checked.

We should add a comment to Shutdown() that it must handle cases in which AppInit2() failed partway.
 

comment number: 56029781 
body: Another option would be to change the initialization logic so that Shutdown() is not run when AppInit2() fails (ie, everything takes care of its own cleanup on failure). This has more code impact, and harder to test, but may be saner in the long term.
 

comment number: 56037766 
body: How about simplifying and doing a quick, unclean, exit(1) if anything in startup initialization fails?
 

comment number: 56037895 
body: Was thinking similar to @gavinandresen -- throw an exception.
 

comment number: 56043328 
body: That sounds very ugly to me. It also breaks any assumption held by the GUI (makes it impossible to report anything back to the user, for example).

Also - things that _are_ initialized must be shut down properly. IE if initializing the wallet fails but the block database has already been fiddled with, the block database must be closed on failure.
 

180. bug report number : ['4639']
comment number: 51249044 
body: Updated title : this is about the sanity check when reading in the fee estimates file.

The best fix is probably to do a sanity check before writing data (or maybe before adding to the fee estimates in memory) in addition to a sanity check when reading.
 

comment number: 339501034 
body: I suspect this issue is no longer relevant given the rewrite - I'm not seeing any sanity checks against the fee levels when reading the file. Can you confirm, @morcos? 

181. bug report number : ['4635']
comment number: 51186444 
body: Any chance of a regression test added to the test suite?
 

comment number: 51186510 
body: @jgarzik The tests already fail without this, on the affected environments.
 

comment number: 51188993 
body: Right, the tests already failed. But no one has been running them with that version of boost, at least on a 32-bit system.

The Boost version used by the pulltester is even older than 1.46, and it passed:

```
#define BOOST_LIB_VERSION "1_40"
```

It's also fine in 1.54+. Seemingly the problem with non-size_t-hashers only exists in a relatively small range of boost versions.
 

comment number: 51311867 
body: Not sure I understand, but `key.GetHash(salt)` gives a uint64_t and we now cast that to size_t? Shouldn't some more places be size_t then and not just this changed return value?
 

comment number: 51313048 
body: @diapolo GetHash() is a 64-bit hash function so it will always give a 64-bit result. 
Casting it to size_t is just to make boost happy. It may chop off the upper 32 bits on systems where size_t is 32 bits, but for a well-designed hash function that doesn't matter as the properties stay the same.
 

comment number: 51332921 
body: @laanwj I would feel better if you could add a small comment about that and why it was changed.
 

comment number: 51344365 
body: Will add a comment.
 

comment number: 51440801 
body: Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4635_6c23b082033b627f31170166c07ab35fa6be9343/ for binaries and test log.
This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/
Contact BlueMatt on freenode if something looks broken.
 

comment number: 51444463 
body: ACK, thanks for adding that comment.
 

comment number: 329957211 
body: @sipa Since `std::unordered_map` is now used instead of `boost::unordered_map`, would it be beneficial to revert `SaltedOutpointHasher::operator()` to return `uint_64t`? 

182. bug report number : ['4607']
comment number: 50721221 
body: Looks like something that may be fixed by #4598
 

comment number: 50998592 
body: This seems to be working/stable for me now.

```
$ git fetch origin pull/4598/head:fix_feeestimate
remote: Counting objects: 12, done.
remote: Compressing objects: 100% (7/7), done.
remote: Total 12 (delta 6), reused 8 (delta 5)
Unpacking objects: 100% (12/12), done.
From https://github.com/bitcoin/bitcoin
 * [new ref]         refs/pull/4598/head -> fix_feeestimate
$ git co fix_feeestimate 
Switched to branch 'fix_feeestimate'
$ cd src/
$ ./autogen.sh ; ./configure ; make
.....
.....
$ ./bitcoind -testnet
```
 

183. bug report number : ['4602']
comment number: 50495827 
body: Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4602_6fd59ee897e9dc9b021440cbb738186dbf3a3e98/ for binaries and test log.
This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/
Contact BlueMatt on freenode if something looks broken.
 

comment number: 50497357 
body: Can we think of a test case that distinguishes these? Or is it just defined versus undefined behavior, where the undefined behavior happens to do the right thing?
 

comment number: 50499879 
body: This is my code. Fwiw, it's very recent.

set_vch() is only called in 2 places. It's range-checked in both places, so there should be no way this could cause any real problems.

Completely agree with the change though, no reason to leave it exposed.
 

comment number: 50858315 
body: ACK
 

comment number: 50874655 
body: Untested ACK
 

184. bug report number : ['4598']
comment number: 50373673 
body: ACK, good catches!
 

comment number: 50380763 
body: Untested ACK
 

comment number: 50427118 
body: unrelated, but I just got several segmentation faults. It turned out that the code below caused the problem.
The scenario was delta=1 and history.size()=0.
If I read the code correctly, this results in -1 index access in the last line.
Maybe we can fix that in this pull request, so I dont have to submit another 'Fix feeestimate'.
(EDIT: I guess for history to be empty, the file fee_estimates.dat has to exist, but with no entries.)

```
    BOOST_FOREACH(const CTxMemPoolEntry& entry, entries)
    {
        // How many blocks did it take for miners to include this transaction?
        int delta = nBlockHeight - entry.GetHeight();
        if (delta <= 0)
        {
            // Re-org made us lose height, this should only happen if we happen
            // to re-org on a difficulty transition point: very rare!
            continue;
        }
        if ((delta-1) >= (int)history.size())
            delta = history.size(); // Last bucket is catch-all
        entriesByConfirmations[delta-1].push_back(&entry); <=========== segfault
    }
```
 

comment number: 50432607 
body: I'd be happy to update the PR, but not sure what the right solution is. I could change the line that seg faulted to: 

```
if (delta > 0)
    entriesByConfirmations.at(delta-1).push_back(&entry);
```

And I _think_ that there isn't anywhere else that would throw an exception, but it seems like the code is not really designed for a history of 0 size.  

Was this the result of reading a corrupted data file?  It would make sense to sanity check the data file on read as well.
 

comment number: 50483560 
body: @cozz : the mystery is how history.size() could ever become zero. Looking at the code, I agree with @morcos -- your estimates.dat file must have been corrupted somehow.

There are already sanity checks in CBlockAverage::Read; adding a sanity check in CMinerPolicyEstimator::Read() like:

```
    filein >> numEntries;
    if (numEntries <= 0 || numEntries > ...uh, some large value...)
         throw runtime_error("Corrupt estimates file.");
```

... and maybe an assert(history.size() > 0) in the right spot(s) would be best fix.
 

comment number: 50497100 
body: The problem is gone after deleting fee_estimates.dat. I assume I was using an old incompatible fee_estimates.dat. So lets not bother much, your suggested sanity checks/asserts sound good to me.
 

comment number: 50515960 
body: I just added another commit to sanity check the reading of the file.  I read fee_estimates.dat into a temporary history vector first, because otherwise the sanity checking could have failed in reading the individual CBlockAverage's and still left an inconsistent state, so I didn't want to replace the state we were initialized with unless we knew processing the whole file succeeded.
 

comment number: 50517486 
body: Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4598_e59441f0863d20c6f205c4854a37507267183863/ for binaries and test log.
This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/
Contact BlueMatt on freenode if something looks broken.
 

comment number: 51304130 
body: Thanks a lot for this, it seems to have solved quite some crashes that people were experiencing, especially on testnet.
 

185. bug report number : ['4523']
186. bug report number : ['4509']
comment number: 48733179 
body: Did you restore a wallet backup at some point?
 

comment number: 48734383 
body: No for 99%. I encrypt wallet on some point of time, but almost sure that happend before 30.06

EDIT: 
I look for debug log and on the moment when I call getnewaddress and I have:
2014-07-11 08:53:09 keypool reserve 5
2014-07-11 08:53:09 keypool keep 5 
No keys from pool are waste.
 

comment number: 158683549 
body: @mgosk Could you reproduce this issue another time?
 

comment number: 372999397 
body: Issue seems stale, closing unless anyone can reproduce 

187. bug report number : ['4493']
comment number: 48457526 
body: Oh, I've just realised that SendMessages() does a TRY_LOCK() on cs_main first, and if it can't get the lock it returns early before calling IsInitialBlockDownload().  So does that mean its not a deadlock risk in actuality?  Although the LOCK() calls are in the opposite order, there may be no chance of deadlock?
 

comment number: 48467411 
body: Well as long as there is one place where both locks are acquired (in any order) that's not a TRY_LOCK, there could be a deadlock there. If they are all TRY_LOCKS then indeed a deadlock cannot happen, but maybe livelock or thread starvation could (if both threads refuse to give up the other lock after getting the other one fails).

As for IsInitialBlockDownload: one idea would be to change it to return a global flag that is cleared only after the initial block download (+ check at initialization time). This would be more efficient than executing the checks every time as well.
 

comment number: 274565444 
body: I'm going to close this, assuming that it was fixed by #7846 or other locking changes in recent time. Feel free to reopen if other problems are found. 

comment number: 276144478 
body: Seen today on 0.13.2:
```
2017-01-30 18:03:10 receive version message: /Satoshi:0.13.1/: version 70014, blocks=1087141, us=38.121.165.30:32483, peer=8
2017-01-30 18:03:10 AdvertiseLocal: advertising address 38.121.165.30:18333
2017-01-30 18:03:10 connect() to [2001:0:9d38:90d7:2cfe:1245:ac28:731a]:18333 failed: Network is unreachable (101)
2017-01-30 18:03:37 POTENTIAL DEADLOCK DETECTED
2017-01-30 18:03:37 Previous lock order was:
2017-01-30 18:03:37  pnode->cs_vRecvMsg  net.cpp:1877 (TRY)
2017-01-30 18:03:37  (1) cs_main  main.cpp:5911
2017-01-30 18:03:37  (2) cs_vSend  net.cpp:2585
2017-01-30 18:03:37 Current lock order is:
2017-01-30 18:03:37  (2) pnode->cs_vSend  net.cpp:1896 (TRY)
2017-01-30 18:03:37  (1) cs_main  main.cpp:6483 (TRY)
2017-01-30 18:03:37  (1) cs_main  main.cpp:1745
2017-01-30 18:03:37 UpdateTip: new best=000000000000093a78ec61c44009ff74a44de94fd6e6b0fff2422804d180c082 height=1087142 version=0x20000000 log2_work=68.931904 tx=13040484 date='2017-01-30 18:03:19' progress=1.000000 cache=2.1MiB(9691tx) warning='1 of last 100 blocks have unexpected version'
2017-01-30 18:03:51 UpdateTip: new best=00000000000005f96e01b15ac4cfb95859e3eecf7f4885274e1f24b3d7e3fde9 height=1087143 version=0x20000000 log2_work=68.931923 tx=13040485 date='2017-01-30 18:03:37' progress=1.000000 cache=2.1MiB(9692tx) warning='1 of last 100 blocks have unexpected version'
2017-01-30 18:04:11 UpdateTip: new best=00000000000008bf5f8409d19de20f248f5b61e391071afd69bc9119efa3c0a4 height=1087144 version=0x20000000 log2_work=68.931941 tx=13040487 date='2017-01-30 18:03:51' progress=1.000000 cache=2.1MiB(9694tx) warning='1 of last 100 blocks have unexpected version'
2017-01-30 18:04:35 connect() to [2001:0:9d38:6ab8:248d:2e3a:983b:b04a]:18333 failed: Network is unreachable (101)
2017-01-30 18:05:58 POTENTIAL DEADLOCK DETECTED
2017-01-30 18:06:00 Previous lock order was:
2017-01-30 18:06:05  pnode->cs_vRecvMsg  net.cpp:1877 (TRY)
2017-01-30 18:06:07  (1) cs_main  main.cpp:5911
2017-01-30 18:06:13  (2) cs_vSend  net.cpp:2585
2017-01-30 18:06:16 Current lock order is:
2017-01-30 18:06:28  (2) pnode->cs_vSend  net.cpp:1896 (TRY)
2017-01-30 18:06:31  (1) cs_main  main.cpp:6483 (TRY)
2017-01-30 18:06:32  (1) cs_main  main.cpp:1745
2017-01-30 18:08:58 UpdateTip: new best=000000000000095216f28d2cd715abee070cd83079411a93463ec61fa2a782eb height=1087145 version=0x20000000 log2_work=68.931959 tx=13040491 date='2017-01-30 18:05:29' progress=1.000000 cache=2.1MiB(9701tx) warning='1 of last 100 blocks have unexpected version'
2017-01-30 18:08:58 POTENTIAL DEADLOCK DETECTED
2017-01-30 18:08:58 Previous lock order was:
2017-01-30 18:08:58  pnode->cs_vRecvMsg  net.cpp:1877 (TRY)
2017-01-30 18:08:58  (1) cs_main  main.cpp:5911
2017-01-30 18:08:58  (2) cs_vSend  net.cpp:2585
2017-01-30 18:08:58 Current lock order is:
2017-01-30 18:08:58  (2) pnode->cs_vSend  net.cpp:1896 (TRY)
2017-01-30 18:08:58  (1) cs_main  main.cpp:6483 (TRY)
2017-01-30 18:08:58  (1) cs_main  main.cpp:1745
2017-01-30 18:08:58 UpdateTip: new best=000000000000024c5841a34b630828a27114c895ac7de8f1cb3376ec7d7a35a1 height=1087146 version=0x20000000 log2_work=68.931977 tx=13040493 date='2017-01-30 18:08:04' progress=1.000000 cache=2.1MiB(9703tx) warning='1 of last 100 blocks have unexpected version'
```

Bitcoin did seem to sync successfully on testnet, and I'm not entirely sure if these message indicated a real problem? 

comment number: 276151595 
body: Yes, this is a spurious warning on many recent versions of Bitcoin Core, however, it is believed to have been "fixed" in master/will be fixed in 0.14. 

188. bug report number : ['4469']
comment number: 64697599 
body: Hmm, why do you think it will crash? Just out of curiosity, I have replaced the call to Genesis() with NULL and it didn't crash here...
... time passes ...
Hmm yes, it crashes here (you have to compile the file after change 8)).
But this can't happen because we initialize genesis inside

bool InitBlockIndex() {
 

comment number: 64700748 
body: So even you run that particular code without the blocks, ./bitcoind -printblocktree -testnet -debug -printtoconsole prints:

```
...
init message: Verifying blocks...
 block index             608ms
0 (blk00000.dat:0x8)  2011-02-02 23:16:42  tx 1
...
```

ie. it doesn't fail - because the Genesis block is added.
 

comment number: 64784767 
body: The code got removed as part of #5385. This issue can be closed now.
 

comment number: 64786934 
body: Hah. Deleting code is the best way to get rid of bugs.
 

189. bug report number : ['4461']
comment number: 47958363 
body: Looks like a bug to me.
 

comment number: 48078425 
body: Interestingly, the numbers in the askfor debug don't match up with the time the blocks are actually getdataed - they are 2 minutes out. I wonder when this broke!
 

comment number: 269345432 
body: #7079 I think has fixed this 

190. bug report number : ['4458']
comment number: 47814597 
body: I think perhaps more importantly than it simply accepting an odd length (which there is nothing wrong with) is the fact it's accepting hex with invalid characters in it.  In particular, the character at the end of the submission is `0xa0`.  Note: That's not `0x0a` (`\n`).

As a test, I submitted the byte sequence `0x22, 0x30, 0x32, 0xa0, 0x22` which is `"02�"` to both `decodescript` and `submitblock`.  Obviously the two `"` will be stripped during the JSON unmarshal.

The call to `decodescript` gives: `-8: argument must be hexadecimal string (not '02�')` which is what one would expect when submitting invalid hex.  However, the same data passed to `submitblock` gives: `-22: Block decode failed` meaning it's accepting the invalid hex and passing it on block decoding.
 

comment number: 47815233 
body: decodescript uses ParseHexV (from rpcserver.cpp), which first calls IsHex, throws an exception if invalid hex, or parses the string if valid.  submitblock uses ParseHex directly, without verifying that the string is valid, and ParseHex ignores all bad input so failure cannot be detected.
 

comment number: 47858512 
body: For reference, ckolivas/cgminer#621 fixes the cgminer bug.
 

comment number: 47860358 
body: While I'm glad the cgminer bug is fixed, I still think `submitblock` should reject invalid hex.
 

comment number: 49467160 
body: cgminer has released a new stable version that includes the fix.

https://bitcointalk.org/index.php?topic=28402.msg7887585#msg7887585

```
- Fixed a corruption when solo mining (ALL SOLO MINERS URGED TO UPGRADE!)
```
 

comment number: 175725521 
body: Not sure since when, but this is no longer an issue.
`DecodeHexBlk`, called by `submitblock` calls IsHex(), which returns false when there are non-hex characters or the number of characters is not an even number.
 

191. bug report number : ['4450']
comment number: 47749369 
body: There's a tradeoff with applying the rate limit before full input validation.  It will save the cost of validation when the tx wouldn't have been relayed anyway due to the rate limit (which could affect all processing), but it allows saturation of the relay rate limit with unsigned spam (which only affects respend relays).
 

comment number: 47802439 
body: Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/p4450_0da6b3fd187da3aa810aaa584d8bd197ad4fa2b9/ for binaries and test log.
This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/
Contact BlueMatt on freenode if something looks broken.
 

comment number: 47970232 
body: ACK.  Code reviewed, and compiled and run on OSX
 

comment number: 47971047 
body: RE: saturating the relay rate limit:  maybe I'm missing something, but I don't see how an attacker can do that because the bloom filter check is done first (and any outpoint hitting the bloom filter does not count against the relay limit).

If an attacker had a huge number of unspent outpoints they might be able to flood the filter. But they would pay for that attack in transaction fees for the first-spends of those outpoints.  If they had a huge number of very old, high-priority outpoints they could flood the filter for free, once-- that mythical attacker could flood the relay-free-transaction filter, too, but as far as I know nobody has done that. Or maybe they have, and nobody noticed because blocking free transactions for a while just isn't very exciting or profitable.
 

comment number: 47979009 
body: Because sigs have not been checked at rate limit check, he can also submit an invalid second spend for every unconfirmed tx he has seen.  Still limited though.
 

comment number: 47979626 
body: I tested the true and false cases for RelayableRespend.  Bloom filter is initialized and functions correctly.  Also I tested that first spend was relayed and added to wallet.  I did not test bloom filter clear.
 

comment number: 48006835 
body: ACK
 

comment number: 48989180 
body: I think this it is a mistake to change the network invariant "double-spends not relayed" that has provided quite a lot of DoS protection since 2009. The current patch looks fine. But it could have unexpected interactions.
I have not actually tested these vulns, but I think they are possible..
1. For example, suppose an attacker has 4000 outputs that he controls. He creates 4000 txs Tx(i) (one for each prevout) with no fees and a size so they have very low priority for miners and then spread them slowly until every node has a copy. These Txs won't be included in blocks for a long long time (months?). Then it's possible to push double-spends over the network by sending three transactions A and B with 2000 inputs each for three sets of 2000 prevouts (from the original 4000 prevouts). If A and B are processed alternatively, A will reset the double-spend bloom filter for the ouputs in B with high probability. Then B will reset those for A, in a loop. With some provisions not to exceed the rate limiter, those 2000-input double spends will probably keep forever going around the network like ghosts until Tx(i) gets into a block (if it ever does), and then the attacker can launch another similar attack by using the remaining outputs.  

So attack cost: fixed initial cost of creating 4000 outputs (maybe around 400 USD), periodic cost of re-creating A and B when a Tx(i) was included in a block.
Attack timespan: forever
Cost to the network: consume all available double-spend bandwidth.

Also there may be problems with orphan transactions
2. A user can slowly load hundreds of orphan double-spend txs, and then release them all at once with a single parent tx, even if all double-spend the same output. This is done by creating multiple versions of A(i) with small changes and multiple versions of B(i) with small changes, but with a missing parent, and then sending the parent, which will trigger the flooding. 

Why not improve the network on-top-of Bitcoin instead of changing this golden rule?

Suppose we change the client so that, along each transaction, it sends an additional message for each input: SmallProof(i) = < Hash(tx), input(i)  > but where the signatures for OP_CHECKSIG are taken over the TX hash, instead of over the transaction and SmallProofs are only generated if only sizeof(scriptSig)<180 bytes.
Then a lightweight double-spend alert system requires just to send the SmallProofs (220 bytes) and any server that wishes to detect 0-confirmation checks that the good SmallProofs exists and no other smallproof has been broadcast (if not, then the money is returned to the sender, or the sender must provide the smallproofs again). To prevent sending BTC from a client that does not support SmallProofs, we create a new kind of Bitcoin address that states "Smallproofs required" using another prefix.

So to summarize this proposal needs:
1. One new kind of inventory item (SmallProof) (current INVs/getdata system could be used)
2. A filter that prevents SmallProofs for being sent more than twice for each prevout.
3. Add the small proofs to CWalletTx to preserve them.
4. A change in CWallet::CreateTransaction() so that both the Tx and the Smallproofs are signed.
5. A new address prefix (optional) so that old-clients cannot recognize these addresses. 
6. A way to inform the user if a Tx comes with SmallProofs and if is had double-spends attempts.

If done properly, none of these modifications should affect old nodes, and we'll have way to achieve 0-confirmations with much higher confidence. 
 

comment number: 49022146 
body: Clarification: Only smallproofs are generated if the payee requires them, so the network overhead will initially be 0%, and will grow slowly as more merchants adopt the new 0-confirmation system. If all transactions required 0-conf, then the network overhead would be aprox. 50%.

Also this system is more politically correct: why the whole network should pay with less security if a bunch of merchants wants to accept 0-confs? Let THEM pay the price of upgrading their systems to this new confirmation method, and let them pay the price to convince users to upgrade their nodes to send 0-confirmation payments. Also it's not clear at all that this patch makes better or worse 0-conf, because as we're broadcasting the double-spends, we're letting miners modify their source code to choose the double-spend if the fees are high enough. With pure rational miners, we're making double-spending more easy!
If you you like the proposal of SmapllProofs (or whatever other marketing name you want to name it), I will hire a programmer and create the patch. I'll do everything I can to prevent this double-spend patch from been merged.
 

comment number: 49023323 
body: A core design decision of Bitcoin was to use fully-spendable outputs instead of partially-spendable accounts for the sole reason that using fully-spendable outputs prevents spamming. For every other possible metric, accounts would have been a better choice than outputs (every new alt 2.0 coin has changed this). But now we're tweaking this to let spam be forwarded again. So we end up with the worst of both designs. Let's honor S.N. and don't try to transform Bitcoin into something it is not. Let's build the double-spend alert system on top of Bitcoin, and not ruin a foundational rule that had a clear intention in the original design.
 

comment number: 49035771 
body: @SergioDemianLerner Thank you very much for your attention and thoughts on this.  Regarding the attacks 1. and 2. that you posit:
1.  Relaying A will not overcome the bloom filter, because only one output is added to the bloom filter.  That is true whether A respends one output or 2000.  Another respend transaction is required to get another output added, so this is the same attack that @petertodd posited.  A determined attacker can overrun some nodes' rate limiters, but I don't yet see the risk of a self-perpetuating attack.
2. Maybe you have found a more fundamental problem with orphan handling: orphans respending another orphan should not be stored.  But anyway, when the parent comes along, how is the "flood" different from all those txes being transmitted without the orphan step?

Regarding overall network design, the current situation is that respends split the network into realms believing one or the other was first.  The network as a whole already contains both.  Relaying when possible just makes the knowledge more homogeneous and actionable.

I notice #4484 is not referenced here directly.  It has straightforward improvements to this.  Your review of it would be greatly appreciated.
 

comment number: 49038073 
body: It gives more information at the cost of decreasing the advantage the first transaction had over the second.

If we don't believe this advantage should exist, and it is just about more information about the network, and double spends are perfectly acceptable, there is a much simpler solution to this problem, namely replace-by-fee.

If we believe this advantage should exist (and fow now I do, even if it's just best effort), we shouldn't help the sender of the second one (the alleged attacker) relay his transactions.
 

comment number: 49039162 
body: RE: not helping the second transaction get his transactions to miners:

This is the fundamental disagreement; I wonder if we can somehow measure how difficult it is for a would-be double-spend-attacker to get a transaction to miners.

If it is easy with the current rules, then I argue this change is definitely positive: it should make transaction recipients more aware that they are being attacked.

If it is difficult with the current rules, then I would agree this might be a net-negative.

My belief is that it would be easy for an attacker to find nodes that are "near" the big miners (Matt's mining backbone network would be a good place to start).
 

comment number: 49047166 
body: @gavinandresen I look as the source code and I see that if every input is a first double-spend, then every input will be added to the bloom filter.
Maybe the intention was do it as you say, but the code reads otherwise. The code should be:

if (pool.mapNextTx.count(outpoint) && !tx.IsEquivalentTo(*pool.mapNextTx[outpoint].ptx))
        {
            relayableRespend = RelayableRespend(outpoint, tx, false, doubleSpendFilter);
            if (!relayableRespend)
                return false;
            BREAK; // <-- 
        }

Nevertheless this may open other DoS possibilities, such as allowing sending a big Tx for each double-spent output from a single Tx. It must be analyzed..
 

comment number: 49049090 
body: Let's recap the method used by merchants to accept 0-conf tx.(as far as I know)
1. They monitor the network in several places.
2. They wait 10 seconds
3. They detect double-spends.

Suppose all miners are fully rational but unscrupulous. This may actually be the average case today, please forgive me if you're a miner and you're not. Then the attacker can just wait 11 seconds and rely a double-spend with much higher fees. Miners will take the second, and not the first. So the whole 0-conf detection idea does not work anymore.
The key difference between SmallProofs of double-spend and double-spend Txs is that the former does not allow a random miner to include double-spend in a block, where the later does.
 

comment number: 49049987 
body: @gavinandresen Regarding your 2nd point about orphans: The point is that a huge amount of traffic can be triggered by a 100 byte message. So if I connect to 1000 nodes, and send each one 1000 double-spend orphans (slowly), then In 1 second I can make 1M messages travel around the network. Who knows how the network will react to such state! It can loop....
An attacker can prevent people for making payments in a crucial time (such as when a bet is closing, or an auction is closing..)
 

comment number: 49053279 
body: Please give me a single argument why double-spend SmallProof notifications are worse than double-spending TXs,  Forget for a moment about the code already written. There much more at stake.

Regarding information: Smallproofs provide more information, because they actually allow users to measure how many transactions are accepted by 0-conf, which is very important to compute risk of block-rollback attacks.

Regarding bandwidth: Smallproofs require a bit more but only if we're not under a massive DoS attack using double-spend Txs, which probably will be quite common. :)

Also the SmallProof system can one day be made part of each transaction by hard-forking and computing the signature hash as Hash( prevout(i) || Hash(Tx-as-is-now) ) , so there will be no bandwidth waste.

Regarding propagation time: Smallproofs propagate much faster. If small enough, they can even be pushed without the need for an INV-getdata interaction.

Regarding SPV: Some SPV may not want to receive double-spend transactions. BitcoinJ may want to, but other clients using block confirmations may not. A SPV node having 10 connection may receive a different double-spend Tx from each peer.

Regarding security: Signing two messages with the same private key MIGHT be bad, if there the signatures are not deterministic and the entropy source is bad. But if entropy source is bad this would allow nodes to predict the private keys generated in the first place (as it happened).

Regarding politics: Give merchants what they want when accepting 0-conf: reduced risk.  With double-spend tx we cannot go and tell them: "we've reduced the risk, here is the proof. ". We can only tell them: "we did something we believe it might reduce the 0-conf risk, but it may actually do the opposite, we don't know, we are just playing with your money. "
 

comment number: 49054085 
body: Thank you for pointing me to #4484. This solves the first attack I proposed.
 

comment number: 49056585 
body: @SergioDemianLerner Just to clarify, by "smallproofs" you mean my proposal of relaying the scriptSig right? Do remember that proposal requires wallets to apply special-case behavior when sending an instant-confirmation payment; it doesn't work with wallets as-is.

Also "computing the signature hash as Hash( prevout(i) || Hash(Tx-as-is-now))" isn't a hard-fork if done sanely. (sane changes are almost never hard-forks)
 

comment number: 49056817 
body: IMHO patch #4484 is buggy. The is an old rule about bugs that states that where a bug is found, there is probably another. With this code we're probably over the fourth.. how many more we'll find?
Also I remember a brief talk with Linus Torvals I had 20 years ago, when I was developing kernel drivers for Linux and he told me the KISS principle. Don't you see this patch breaks the KISS principle?
 

comment number: 49056895 
body: @SergioDemianLerner : I think you meant to tag @dgenr8  RE: a possible orphan flood attack.

I've been thinking for about a year or so that storing orphan transactions is a bad idea; we could simplify the code if we got rid of mapOrphans and related, and just rely on transaction senders/receivers to rebroadcast transactions that they want mined.  KISS
 

comment number: 49057514 
body: @petertodd I don't have your proposal at hand, can you send me the link? It seems that we're talking about the same. It requires the wallets to do something special, namely sign a small message along the transaction, and broadcast this message, before or after the transaction.
 

comment number: 49057551 
body: @gavinandresen Re-broadcasting transactions frequently fails when all your peers have a tx but for whatever reason miners don't; need replace-by-fee or similar in that case to ensure everyone re-propagates your tx. For instance https://github.com/bitcoin/bitcoin/pull/2340 needs to be neutered right now because we don't rebroadcast orphans when we get the block.
 

comment number: 49058156 
body: @SergioDemianLerner We're talking about different things I think; my scheme doesn't require signing messages of any kind. My proposal was written up here: https://github.com/bitcoin/bitcoin/pull/3883#issuecomment-45543370
 

comment number: 49065970 
body: @gavinandresen +1

@petertodd The mempool janitor PR (#3753) and related issues (#3722, #3723) also handle that, to a certain extent.
 

comment number: 49067681 
body: @petertodd Your method works by preventing the use of a private key twice. I like it. But it has problems if the user has a single Bitcoin address to receive payments.

My method does not require a hard fork and can be implemented in different ways. Here is one:

First the wallet signs two messages with each private key: the tx and a smallproof msg.
We make 0-conf outputs require anything that today is non-standard, such as pushing dummy 1 value before the signature script.

scriptpub: OP_DROP OP_DUP OP_HASH160 < pubKeyHash > OP_EQUALVERIFY OP_CHECKSIG
scriptsig: < sig > < pubKey > < dummy-val >

So these transaction will not be normally relayed.
Now we add the rule add these transactions ARE relied if the the smallproof message has been previously received.
So the smallproof message "pays" for the transmission of the non-standard tx.
If an attacker wants to send two double-spending txs, he won't be able to "pay" for the transmission of both without creating to colliding smallproofs that will be detected by the merchant.
 

comment number: 49068847 
body: I think the smallproof idea deserves a more formal presentation because this is not the appropriate place to do it, so I will describe it in more detail in the mailing-list.
 

comment number: 49068925 
body: @SergioDemianLerner Your method requires a soft-fork to be secure. I could easily make a Bitcoin Core fork that treats those outputs as standard without the smallproof message; Eligius among others would happily accept them. My scriptSig relaying mechanism OTOH works regardless of what policy miners follow, and with scorched-earth, gives them incentives to "defect" and broadcast double-spend proofs to collect even higher fees.
 

comment number: 49075375 
body: This change has about the smallest footprint possible for what it achieves.  KISS.

The problem with an as-yet unimplemented Better Solution is that it is not implemented, or even really designed.  If it is implemented, it will be subject to the same level scrutiny, and it sounds like it has a MUCH larger footprint than this one.  There will be more bugs, not less.  There will be more risks.

I hope no one is giving too much weight to grave accusations being made which turn out to be based on fundamentally flawed assumptions and flawed reading of the actual commits.

This is a small change with outsized positive effects for the network.
 

comment number: 49080939 
body: These special alert ideas require the cooperation of the creating wallet?  tx relay is so much better than that!

Highlighting another advantage that we discovered as we vetted and completed this change -- it works seamlessly with no additional code when a miner decides to spring a double-spend on the world in a block.  Let's not be too steeped in technology to remember that we are really trying to influence a REAL WORLD event of handing-over-the-goods.  Failure does not occur when the double-spend is confirmed.  It occurs when the goods are handed over and the original spend is never eventually confirmed.  Failure can be prevented by notification.
 

192. bug report number : ['4433']
comment number: 274561793 
body: Is this still the case? 

comment number: 274619540 
body: I tried this on 12.0 and did not see the problem as described.  Strangely though, it was not listening, even with no connect or proxy.  Having this issue around does not seem useful so I'll close it. 

193. bug report number : ['4345']
comment number: 46171309 
body: FWIW that backtrace appears to go off the rails inside leveldb, IIRC.
 

comment number: 46188847 
body: Testing with 0.9.2, it did not crash (overnight) reloading the bootstrap.dat, but it ended at block 278356 with a ton of orphan blocks, and not downloading anything despite having lots of peers (26).

This is what happened to me with 0.9.1...I was unable to synchronize with the network at all because it stopped downloading blocks.  Someone on IRC suggested that my blockchain was corrupted, which led to me trying to reload everything.  Right now I'm running a -reindex.

I don't understand why 0.9.1 and 0.9.2 ended up stalled in downloading the blockchain (orphan blocks?) which seems to be a separate problem to the SIGSEV's above.  For now I will bisect and/or valgrind to find the memory corruption, but I'd appreciate suggestions about what else is going on that is preventing me from downloading the entire blockchain.
 

comment number: 46191939 
body: Network blockchain download stalls are (unfortunately) common and have nothing to do with corruption.

Just stop and restart, if you get impatient.
 

comment number: 46193681 
body: By "stall" I mean more than 3 weeks, many (at least 10) restarts, and never progressing past a particular block.  The cause seemed to be this:

> 2014-06-14 20:00:23 CheckForkWarningConditions: Warning: Large valid fork found  forking the chain at height 285298 (0000000000000000ea7984d2eef34d494e5ec5c31607f396f4a2b1decb6a1ca7)
>   lasting to height 305806 (00000000000000000018257d507dcb0365a9176fe3aaa0e9539b0d9a3a5b5570).
 

comment number: 46195459 
body: That's strange (and abnormal). It's starting to sound like something is wrong on your machine causing database and/or memory corruption.
 

comment number: 46196641 
body: I've run memtest and not found anything.  I'm writing a little python script to run sha256 in circles and check for inconsistencies...
 

comment number: 46323884 
body: Further examining the possibility of bad hardware, I wrote this little script.  It detected a hardware problem so I under-clocked my CPU and the problem seems to have gone away.  I did see crashes with v0.9.2 but right now it is running and synchronized.  

I see a few other "issues" involving ORPHAN BLOCK (etc).  It might be a good idea to hand this script to people who report problems synchronizing the blockchain to check their hardware.  I had to run it for several hours before it reported an error, but bitcoin is very sensitive to a single hash being computed incorrectly.

```
#!/usr/bin/python

# Repeatedly run a sha256 on random data.  Keeps a rolling buffer of the last
# <buflen> hashes and re-checks them.  Prints an error ONLY if a mismatch is
# found.  If a mismatch is found, you have a hardware problem.

from hashlib import sha256
from collections import deque
import random

buflen = 100000
hashbuf = deque(maxlen=buflen)

for i in range(buflen):
    hashbuf.append([str(i), sha256(str(i)).hexdigest()])

while True:
    k, khash = hashbuf.popleft()
    pophash = sha256(k).hexdigest()
    if pophash != khash:
        print "ERROR: sha256(%s) = %s does not match:"%(k, khash)
        print "       sha256(%s) = %s"%(k, pophash)
    k = str(random.getrandbits(1000))
    khash = sha256(k).hexdigest()
    hashbuf.append([k, khash])
```

Please close this issue.
 

comment number: 46324827 
body: Ok, thanks for letting us know.
 

comment number: 46400226 
body: FYI I've run various stress tests with master, importing bootstrap.dat files with different degrees of parallelism over the last few days, and not one crash or instance of corruption.
 

194. bug report number : ['4266']
comment number: 44770211 
body: yes there are some limitations to the configuration at this point. @diapolo  has a pull open for a long time which may make this possible, see #2575. Please help testing.
 

comment number: 45729555 
body: @slacks42 Did you test with my patch?
 

comment number: 184677977 
body: Closing due to inactivity
 

195. bug report number : ['4263']
comment number: 44743734 
body: There are known corruption problems on ARM.
 

comment number: 45092915 
body: I've run quite a few nodes on ARM boxes and have never encountered corruption problems.

The only thing that you shouldn't do is copy the leveldb database files between ARM and x86, they are incompatible in subtle but messy ways (see #2293).
 

comment number: 46194527 
body: Thanks laanwj, I tried deleting all blocks and chainstate files and it still didn't work for me, it'd just fail in different ways errors were all related to the DB.  
I'm building 0.9.2 now, will try with that.
 

comment number: 53049949 
body: Rippler how big is your db ?

At which level ? *

*http://dailyjs.com/2013/04/19/leveldb-and-node-1/#%21
 

comment number: 53051826 
body: Sorry it's been 60+ days I think I waited for a week and then tried various things and messed the system up. I'll post back if I resurrect that system.
I had several bugs at various stages so I can't remember which bug happened at which level, but I think at the very end when this happened I think blockchain was downloaded up to block 200K or thereabout (hopefully you can guess which level that is).
 

196. bug report number : ['4246']
comment number: 44543040 
body: I believe the problem is that when processing the block, the header is already processed. This means that 290000's header is already in mapBlockIndex when its block data is processed. As that invokes CheckBlock, which on its turn invokes CheckBlockHeader again, which calls GetLastCheckPoint, which returns the block being verified itself, and then compares its parent against that, resulting in time seemingly going backward.

Two possible solutions:
- Make GetLastCheckpoint take the verification level of the mapBlockIndex passed into account, and ignore not-fully-validated ones (easier).
- Pass chainActive to GetLastCheckpoint instead of mapBlockIndex, which will never contain a block itself while it is still being verified (cleaner, imho).
 

comment number: 44547152 
body: I'm probably wrong.
 

197. bug report number : ['4235']
comment number: 274560683 
body: I believe this is no longer the case since at least #5677 or earlier. 

comment number: 305664966 
body: Could not reproduce with master.

``` bash
while true; do ./src/bitcoin-cli getinfo && sleep 0.1; done
```

``` bash
./src/bitcoin-cli stop
```

No delay.  Synced node.
Loop dumped out the following immediately after the server stopped (as expected).
```
(make sure server is running and you are connecting to the correct RPC port)
error: couldn't connect to server: unknown (code -1)
``` 

198. bug report number : ['4231']
comment number: 184678810 
body: For some reason it continues processing after a bad allocation, crashing on an assertion failure later.
Duplicate of #7228.
 

199. bug report number : ['4224']
comment number: 47426457 
body: You're right. The formula in comments seems to imply that a single-byte push suffices.
 

comment number: 47598497 
body: Ha, good catch! I knew a few extra bytes would turn out to be a good idea.
 

200. bug report number : ['4184']
comment number: 43015838 
body: Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/122549f6dee5f4d4daf7091d6302c38ba13ffb01 for binaries and test log.
This test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/
Contact BlueMatt on freenode if something looks broken.
 

comment number: 43057984 
body: What steps did you take to get this information?
How to verify this?
 

comment number: 43091282 
body: getblock 000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70 (checkpoint 546) shows time of "1337966069".

Regarding the total number of TXs, I wrote code to check:

```
package main

import (
        "fmt"
        "github.com/conformal/btcrpcclient"
)

var (
        client *btcrpcclient.Client
)

func CountTxs(count int64) (uint64, error) {
        totalTxs := uint64(0)
        for i := int64(0); i <= count; i++ {
                sha, err := client.GetBlockHash(i)
                if err != nil {
                        return 0, err
                }
                blk, err := client.GetBlock(sha)
                if err != nil {
                        return 0, err
                }
                txs := len(blk.Transactions())
                totalTxs += uint64(txs)
        }
        return totalTxs, nil
}

func main() {
    var err error
        cfg := btcrpcclient.ConnConfig{
                Host:         "127.0.0.1:18332",  // testnet
                User:         "dajohi",
                Pass:         "mypass",
                HttpPostMode: true,
                DisableTLS:   true,
        }
        client, err = btcrpcclient.New(&cfg, nil)
        if err != nil {
                fmt.Printf("%v\n", err)
                return
        }


        total, err := CountTxs(546)
        if err != nil {
                fmt.Printf("CountTxs error: %v\n", err)
                return
        }
        fmt.Printf("total txs: %d\n", total)
}
```

<pre>
$ go run txcount.go
total txs: 1488
</pre>
 

comment number: 44376952 
body: ACK

``` python
from __future__ import division,print_function
from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException
import sys

tgt = sys.argv[1]
count_to = int(sys.argv[2])
proxy = AuthServiceProxy(tgt)
total = 0

for block in range(count_to+1):
    blockhash = proxy.getblockhash(block)
    info = proxy.getblock(blockhash)
    total += len(info['tx'])

print('Total transactions:', total)
print('Time of last block:', info['time'])
```

``` bash
$ python count_transactions.py http://bitcoinrpc:AbmPZxYieDW6DosvA8S3VjCA7zb3mi49h4HqzdDJXvQ@127.0.0.1:18332 546
Total transactions: 1488
Time of last block: 1337966069
```
 

201. bug report number : ['4156']
comment number: 42642099 
body: Ok, the problem seems to be that the boost::asio::io_service destructor waits for the acceptors to finish (on windows, with this version of boost). This never happens as they are not cancelled. Same for the timers, I think.
 

comment number: 42642300 
body: Added a commit to #4142 to solve this.
 

202. bug report number : ['4151']
203. bug report number : ['4147']
comment number: 42478227 
body: Overwriting LC_ALL with a fixed value is quite an ugly solution (busybox may not use locales, but we do).

Isn't there something more specific that can be done about the boost error?
 

comment number: 42480197 
body: I tried catching the error & then setting the environment without success
 

comment number: 42481999 
body: Is this caused by the use time_input_facet in DecodeDumpTime in rpcdump.cpp?
 

comment number: 42482983 
body: This error is thrown in AppInit() - setting LC_ALL in AppInit2() did not fix the problem
 

comment number: 42483560 
body: If your system doesn't use locales, then setlocale(_any_, "" _or_ NULL) should simply return "C", and setlocale(_any_, _anything else_) should return NULL. If that is causing problems in boost or bitcoind, those problems should be fixed rather than forcing the "C" locale.
 

comment number: 42484333 
body: this was in bitcoinrpc.cpp in the namecoin sources but it did not force a C locale

```
string locale(setlocale(LC_TIME, NULL)); 
```
 

comment number: 42485158 
body: You keep talking about namecoin.

Do we, in the current master version of bitcoin, have anything that generates this error?

If so, where is it raised? Where does the exception originate from? It must be some usage of boost. Can we avoid that, maybe by passing in our own locale object instead of using the system one?

**Edit:** I see we indeed use setlocale here: https://github.com/bitcoin/bitcoin/blob/master/src/rpcprotocol.cpp#L52 . That's not thread-safe at all. But it appears that the exception is raised at at start-up, so it cannot be caused by that.
 

comment number: 42487690 
body: The exact error in Bitcoin is:

```
terminate called after throwing an instance of 'std::runtime_error'
  what():  locale::facet::_S_create_c_locale name not valid
Aborted
```
 

comment number: 42488116 
body: And which code throws it?
 

comment number: 42488649 
body: just running 'bitcoind --help' is enough to generate the error - any command will generate the same error on a machine without locales.

A default C locale should be set.
 

comment number: 42488978 
body: I don't want an ugly workaround hack unless we know what code throws this error, and that there is no other way to avoid the problem.
 

comment number: 42489540 
body: I don't understand how this happens in the first place: boost raises this error if it cannot find the selected locale.
As @luke-jr says, the "C" locale is selected by default if you have not set another locale (so if LC_\* is not set).
Where does it get this information from? Can you show your environment?
 

comment number: 42490402 
body: ```
uclibc [~/packages/testing/x86]$ printenv
PAGER=less
PS1=\[\e[1;32m\]\h [\[\e[0m\]\w\[\e[1;32m\]]$ \[\e[0m\]
TERM=xterm
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
LANG=en_US.UTF-8
SHELL=/bin/ash
CHARSET=UTF-8
EDITOR=nano
```

A C environment is not being set by default on bitcoin or namecoin - as already noted 'setlocale(LC_TIME, NULL)' does not force a C environment on Busybox (Alpine Linux)
 

comment number: 42490764 
body: > LANG=en_US.UTF-8

This may be the culprit if you don't have the en_US locale.
Can you try undefining it?
 

comment number: 42491021 
body: It seems the way most software handles unknown locales is to ignore them. We should do the same...
 

comment number: 42491863 
body: Removing 'LANG=en_US.UTF-8' fixed the issue - so setlocale NULL does work - just need to handle unknown locales
 

comment number: 42491986 
body: I managed to reproduce it by setting LC_ALL to a random value. It looks like boost::filesystem is raising this, line 975 in util.cpp is where it happens.

```
#0  0x00007ffff66c1a30 in __cxa_throw () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#1  0x00007ffff6713677 in std::__throw_runtime_error(char const*) () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#2  0x00007ffff66df0c4 in std::locale::facet::_S_create_c_locale(__locale_struct*&, char const*, __locale_struct*) () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#3  0x00007ffff66d42e9 in std::locale::_Impl::_Impl(char const*, unsigned long) () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#4  0x00007ffff66d530d in std::locale::locale(char const*) () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6
#5  0x00007ffff79ce2c2 in boost::filesystem::path::codecvt() () from /usr/lib/x86_64-linux-gnu/libboost_filesystem.so.1.54.0
#6  0x00005555556e5bea in path<char*> (source=<synthetic pointer>, this=0x7fffffffd750) at /usr/include/boost/filesystem/path.hpp:139
#7  GetDefaultDataDir () at util.cpp:975
#8  0x00005555556e79ed in GetDataDir (fNetSpecific=<optimized out>) at util.cpp:1014
#9  0x000055555558bb0f in AppInit (argc=2, argv=0x7fffffffddc8) at bitcoind.cpp:68
#10 0x0000555555582a9a in main (argc=2, argv=0x7fffffffddc8) at bitcoind.cpp:180
```

So it somehow uses the locale to determine the codec for filename conversion... you'd say it only needs the second part (UTF-8) but meh...
 

comment number: 42493511 
body: Are filename encodings really supposed to be based on the current locale?!
 

comment number: 42493883 
body: @luke-jr Yes, that's one of the things that used to be determined by the locale. Though these days, everything is UTF-8.

This seems to be the only workaround that works, up until now

``` c++
#ifndef WIN32
    try
    {
        boost::filesystem::path::codecvt() // Raises runtime error if current locale is invalid
    } catch(std::runtime_error &e)
    {
        setenv("LC_ALL", "C", 1); // Force C locale
    }
#endif
```

I've tried various other things I found in the boost and std documentation, but to no avail:

``` c++
std::setlocale(LC_ALL, "C");
std::locale::global(std::locale("C"));
boost::filesystem::path::imbue(std::locale("C"));
```
 

comment number: 42517941 
body: I tried your solution with error trapping (on both bitcoin & namecoin) but unfortunately it doesn't work. Libboost exits on locale errors:

```
terminate called after throwing an instance of 'std::runtime_error'
  what():  locale::facet::_S_create_c_locale name not valid
```

https://svn.boost.org/trac/boost/ticket/9182
https://svn.boost.org/trac/boost/ticket/9190
 

comment number: 42518271 
body: Try replacing std::locale() with boost::filesystem::path::codecvt() in the above
 

comment number: 42520179 
body: See revised patch https://github.com/bitcoin/bitcoin/issues/4147#issuecomment-42693934
 

comment number: 42693934 
body: Revised patch to also include bitcoin-qt:

```
--- ./src/bitcoin-cli.cpp
+++ ./src/bitcoin-cli.cpp
@@ -53,6 +53,16 @@

 int main(int argc, char* argv[])
 {
+    #ifndef WIN32
+    try
+    {
+        boost::filesystem::path::codecvt(); // Raises runtime error if current locale is invalid
+    } catch(std::runtime_error &e)
+    {
+        setenv("LC_ALL", "C", 1); // Force C locale
+    }
+    #endif
+
     try
     {
         if(!AppInitRPC(argc, argv))
--- ./src/bitcoind.cpp
+++ ./src/bitcoind.cpp
@@ -166,6 +166,16 @@

 int main(int argc, char* argv[])
 {
+    #ifndef WIN32
+    try
+    {
+        boost::filesystem::path::codecvt(); // Raises runtime error if current locale is invalid
+    } catch(std::runtime_error &e)
+    {
+        setenv("LC_ALL", "C", 1); // Force C locale
+    }
+    #endif
+
     bool fRet = false;

     // Connect bitcoind signal handlers
--- ./src/qt/bitcoin.cpp.orig
+++ ./src/qt/bitcoin.cpp
@@ -445,6 +445,16 @@
 #ifndef BITCOIN_QT_TEST
 int main(int argc, char *argv[])
 {
+#ifndef WIN32
+    try
+    {
+        boost::filesystem::path::codecvt(); // Raises runtime error if current locale is invalid
+    } catch(std::runtime_error &e)
+    {
+        setenv("LC_ALL", "C", 1); // Force C locale
+    }
+#endif
+
     /// 1. Parse command-line options. These take precedence over anything else.
     // Command-line options take precedence:
     ParseParameters(argc, argv);
```
 

comment number: 42734294 
body: Let's move the workaround to a function instead of repeating it three times.
 

comment number: 42763464 
body: `SetupEnvironment()` : https://github.com/bitcoin/bitcoin/pull/4174#commits-pushed-2816491
 

comment number: 42765031 
body: There was an idea about adding some module with several runtime self-tests (/cc @laanwj @theuni). This could include testing the availability of EC support for secp256k1 in OpenSSL.
 

comment number: 42765035 
body: Also, can you submit pull requests instead of patches as text in issues?
 

comment number: 42800565 
body: @sipa #4081 is the issue for that; but this may be too early in the start process to do the self-tests. Adding those tests in the beginning of Appinit2() and sending an InitError() would allow giving a pop-up message in the GUI.
 

comment number: 42857000 
body: @itoffshore I've had several fights with busybox configs over locale data. It depends largely on your toolchain and whether things get installed properly or not (locale data from toolchain's gconv or iconv, etc). strace is helpful to see where it's looking and failing.
There are also fun libc bugs like Bionic's where setlocale(LC_ALL, NULL) returns NULL rather than the current locale, so if you're using some exotic libc, don't expect busybox to know all about it.
It's worth keeping in mind also: if your shell specifies a locale that your c runtime can't provide, bitcoin is likely the least of your concerns.

That said, the approach here seems to line up with what I've found to be the most reliable in the past: set LC_ALL to the C locale (which is IIRC guaranteed), then use c++ locales when it's actually necessary.
 

comment number: 42857684 
body: Sorry, by busybox configs, I was referring to buildroot configs. I assume that busybox in this case comes from buildroot, but I suppose that's not necessarily true.
 

204. bug report number : ['4140']
comment number: 42391403 
body: Seems there is an on click action, which doesn't work, when there is no QR Code or such a thing.
 

comment number: 42392666 
body: Good catch
 

comment number: 42394410 
body: See #4141
 

comment number: 44589361 
body: This issue can be closed as it has been fixed.
 

205. bug report number : ['4139']
comment number: 42345406 
body: Looks like VerifyDB needs a lock on cs_main.
 

comment number: 42424987 
body: Fixed through a475285a535ca4834df51569f1d252307fd6d13c
 

206. bug report number : ['4125']
comment number: 42154812 
body: would have been useful if the debug.log had included the parts from before you forked.
 

comment number: 42155361 
body: I restarted the client before posting the issue, sorry. I have no idea where to look for old logs...
 

comment number: 42164881 
body: ```
2014-05-04 20:47:03 CheckForkWarningConditions: Warning: Large valid fork found
  forking the chain at height 284170 (0000000000000001ca4532061c5410c6acaf8fb47119b5ada2e9d421dacfed54)
  lasting to height 299128 (0000000000000000502bb5f16c22ee26d66479a285d79fa33c48212e8cf8d0bd).
Chain state database corruption likely.
```

So it thinks that the main chain is a fork. All new blocks that it receives are seen to be part of this fork, instead of the most-work chain. I wonder that it thinks to be the best chain, then?

Well, 

```
2014-05-02 18:36:58 LoadBlockIndexDB(): hashBestChain=0000000000000001ca4532061c5410c6acaf8fb47119b5ada2e9d421dacfed54 height=284170 date=2014-02-04 19:53:15 progress=0.599675
```

So it _is_ on the main chain, not even on a perceived fork. No idea what went wrong here...
 

comment number: 42170787 
body: Might this be the same issue as #2726?
 

comment number: 42187264 
body: Yes, seems to be the case. Not that #2726 is a single issue really - it's just "chain validation fails for some unexplained reason".
 

comment number: 42282102 
body: #4064 looks very similar as well
 

comment number: 42367893 
body: Could be. I tried running with -reindex -par=1 and it got stuck at 15 weeks (instead of 12). CMD game me an I\O error (corrupted db) and crashed. Same thing on my laptop (completely different hardware). Should I try different version (32 bit perhaps) ?
 

comment number: 42929836 
body: I got stucked in November 2013. Reindex with par=1 fixed it. 
 

207. bug report number : ['4112']
comment number: 103022643 
body: That indeed sounds like a bug. Delete without a selection should not delete anything.
 

comment number: 307974427 
body: This is no longer an issue. A new address is selected after one is deleted, and that is deleted if you click deleted. 

208. bug report number : ['4091']
comment number: 41305818 
body: Note that the log in https://github.com/bitcoin/bitcoin/issues/3997#issuecomment-41220141 has more examples of these warnings, and was from a bitcoin-qt built from the same commit.
 

comment number: 41508675 
body: I've noticed that if I run bitcoin-qt with a large wallet.dat loaded, it locks up for over 3 minutes each time a block is found, with one of the CPU cores using 100% CPU flat out.  The debug.log shows:

```
2014-04-27 20:39:26 UpdateTip: new best=00000000000000005af8d5387a8a595ed2a34167c55b14cdcaa97e5c380f6c7b  height=298031  log2_work=78.256738  tx=37671615  date=2014-04-27 20:38:52 progress=0.999998
2014-04-27 20:39:26 ProcessBlock: ACCEPTED
2014-04-27 20:42:40 ERROR: AcceptToMemoryPool : inputs already spent
```

Note over 3 minutes of nothing between the 2nd and 3rd lines.  Another example:

```
2014-04-27 20:30:45 UpdateTip: new best=000000000000000020365ab82fbf0d69b29f3c8889acd8241f4bf97951d6995a  height=298028  log2_work=78.256379  tx=37671170  date=2014-04-27 20:31:03 progress=1.000001
2014-04-27 20:30:45 ProcessBlock: ACCEPTED
[3 minute gap]
2014-04-27 20:33:54 Peer 176.67.167.236:8333 is stalling block download, disconnecting
2014-04-27 20:33:54 ERROR: AcceptToMemoryPool : inputs already spent
2014-04-27 20:33:55 ERROR: AcceptToMemoryPool : inputs already spent
2014-04-27 20:33:55 POTENTIAL DEADLOCK DETECTED
2014-04-27 20:33:55 Previous lock order was:
2014-04-27 20:33:55  pnode->cs_vRecvMsg  net.cpp:1537
2014-04-27 20:33:55  (1) cs_main  main.cpp:3718
2014-04-27 20:33:55  (2) cs_vSend  net.h:449
2014-04-27 20:33:55 Current lock order is:
2014-04-27 20:33:55  (2) pnode->cs_vSend  net.cpp:1556
2014-04-27 20:33:55  (1) cs_main  main.cpp:4206
2014-04-27 20:33:55  (1) cs_main  main.cpp:1313
2014-04-27 20:33:55 ERROR: AcceptToMemoryPool : inputs already spent
```

If I run bitcoind instead, I don't see these delays when blocks are found.

Both bitcoin-qt and bitcoind were built from commit 89bbd54fbfbb1b21257d436731868455821a101e.
 

comment number: 41517478 
body: Can you profile where it spends all that time?

I still don't have any large-wallet cases to test with, so cannot reproduce this myself.
 

comment number: 41522459 
body: What tool do you recommend for profiling on Linux?
 

comment number: 41522713 
body: Also, I think you can make a large wallet by calling 'getnewaddress' in a loop lots of times.  I don't know if it matters that they have lots of different labels like my large wallet does.
 

comment number: 41522946 
body: That wouldn't be a very realistic use case. Large wallets also have lots of incoming and outgoing transactions.

As for profiling, I think using gprof is easiest, although there are many other tools available under Linux such has callgrind, oprofile, sysprofile which may work better in some cases.
 

comment number: 41523997 
body: I tried a very simple approach of hitting control-C in gdb while it was busy and asking 'where' over and over.  All 19 times it reported being in:

```
#33 0x00005555556611fb in TransactionTableModel::updateConfirmations (
    this=0x5555567373d0) at transactiontablemodel.cpp:264
#34 0x00005555556147ea in WalletModel::pollBalanceChanged (
    this=this@entry=0x55555618d6d0) at walletmodel.cpp:118
#35 0x000055555562c670 in WalletModel::qt_static_metacall (_o=0x55555618d6d0, 
    _c=<optimized out>, _id=10, _a=0x7fffffffd850) at moc_walletmodel.cpp:82
#36 0x00007ffff61ed87a in QMetaObject::activate(QObject*, QMetaObject const*, int, void**) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
```

Is that enough to go on?

I counted each of the file:line references in the 19 backtraces I got.  Here are the common ones, with the counts:

```
 6 transactiontablemodel.cpp:199
 7 transactiontablemodel.cpp:611
 9 transactiontablemodel.cpp:614
10 sync.cpp:42
10 transactiontablemodel.cpp:196
11 sync.cpp:84
14 sync.cpp:123
```

These line numbers are in a recent HEAD commit c63b2e25a59c602de182a376313ad5d3d62d5045
 

comment number: 41524159 
body: I notice that 11 of the 19 times I interrupted it, it was running:

```
LogPrint("lock", "Locking: %s\n", locklocation.ToString());
```

It seems that `CLockLocation::ToString()` is heavy.
 

comment number: 41525102 
body: So probably a case of locking contention. Maybe due to the lock debugging itself. Try turning it off when you do performance profiling :)
 

comment number: 41526384 
body: With the lock debugging disabled, each new block still ties up the CPU (and freezes the window) for a period of time, but it's less than a minute, rather than being over 3 minutes.

It's now spending all the time here:

```
#4  0x00007ffff61ed87a in QMetaObject::activate(QObject*, QMetaObject const*, int, void**) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#5  0x00007ffff6237527 in QAbstractItemModel::dataChanged(QModelIndex const&, QModelIndex const&) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#6  0x0000555555660e6b in TransactionTableModel::updateConfirmations (
    this=0x55555685c340) at transactiontablemodel.cpp:264
#7  0x0000555555613909 in WalletModel::pollBalanceChanged (
    this=this@entry=0x555556185d70) at walletmodel.cpp:118
```
 

comment number: 41526443 
body: > probably a case of locking contention

That wouldn't cause the CPU to get pegged at 100% would it?
 

comment number: 41526830 
body: > That wouldn't cause the CPU to get pegged at 100% would it?

@dooglus it could; threads would be fighting over the lock which can certainly max out a CPU

I wonder if it generates data changed events, updating the number of confirmations for _every_ transaction instead of just the ones visible on the screen (which is the intention). Performance here could be improved in any case, thanks for getting to the bottom of this.
 

comment number: 41529865 
body: I recompiled and profiled with gprof.  The output is huge, and I'm not sure how to read it.  From what I can see it doesn't draw attention to the call chain I pasted above.

Here are the top few chains it shows:

```
granularity: each sample hit covers 2 byte(s) for 0.00% of 589.66 seconds

index % time    self  children    called     name
                                                 <spontaneous>
[1]     64.5    0.54  380.06                 TransactionFilterProxy::filterAcceptsRow(int, QModelIndex const&) const [1]
                0.38  319.03 5581880/5582004     QModelIndex::data(int) const [2]
                0.77   59.45  930967/930979      TransactionTableModel::index(int, int, QModelIndex const&) const [18]
                0.10    0.06  930871/930871      QString::contains(QString const&, Qt::CaseSensitivity) const [1309]
                0.09    0.00  930878/930906      QModelIndex::~QModelIndex() [1651]
                0.03    0.05 1861938/26802754     QString::~QString() [483]
                0.06    0.00  931139/931139      QBool::operator void const*() const [1990]
                0.03    0.00  930276/930280      TransactionFilterProxy::TYPE(int) [2654]
                0.02    0.00  930954/931286      QDateTime::operator>(QDateTime const&) const [3129]
-----------------------------------------------
                0.00    0.01     124/5582004     TxViewDelegate::paint(QPainter*, QStyleOptionViewItem const&, QModelIndex const&) const [4489]
                0.38  319.03 5581880/5582004     TransactionFilterProxy::filterAcceptsRow(int, QModelIndex const&) const [1]
[2]     54.2    0.38  319.03 5582004         QModelIndex::data(int) const [2]
                1.47  317.56 5581254/5581254     TransactionTableModel::data(QModelIndex const&, int) const [3]
-----------------------------------------------
                1.47  317.56 5581254/5581254     QModelIndex::data(int) const [2]
[3]     54.1    1.47  317.56 5581254         TransactionTableModel::data(QModelIndex const&, int) const [3]
                0.20  314.05  928783/928808      AddressTableModel::labelForAddress(QString const&) const [4]
                0.39    0.69 24692085/26802754     QString::~QString() [483]
                0.80    0.00 23762806/24299209     QString::fromStdString(std::string const&) [601]
                0.57    0.00 27433453/27433453     QModelIndex::isValid() const [720]
                0.48    0.00 27472122/27472122     QModelIndex::internalPointer() const [791]
                0.32    0.00 21898093/21898093     QModelIndex::column() const [947]
                0.05    0.00  930672/930699      WalletModel::getAddressTableModel() [2157]
                0.00    0.02      19/19          TransactionTableModel::formatTxToAddress(TransactionRecord const*, bool) const [3478]
                0.00    0.00       7/7           TransactionTableModel::addressColor(TransactionRecord const*) const [5141]
                0.00    0.00      20/20          TransactionTableModel::txAddressDecoration(TransactionRecord const*) const [7229]
                0.00    0.00      12/47          QColor::QColor(int, int, int, int) [11149]
-----------------------------------------------
                0.00    0.00       6/928808      TransactionTableModel::addressColor(TransactionRecord const*) const [5141]
                0.00    0.01      19/928808      TransactionTableModel::lookupAddress(std::string const&, bool) const [3479]
                0.20  314.05  928783/928808      TransactionTableModel::data(QModelIndex const&, int) const [3]
[4]     53.3    0.20  314.05  928808         AddressTableModel::labelForAddress(QString const&) const [4]
                0.07  293.29  930445/948840      CBitcoinAddress::CBitcoinAddress(std::string const&) [5]
                0.05   16.44  930124/930124      std::map<boost::variant<CNoDestination, CKeyID, CScriptID, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_>, CAddressBookData, std::less<boost::variant<CNoDestination, CKeyID, CScriptID, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_> >, std::allocator<std::pair<boost::variant<CNoDestination, CKeyID, CScriptID, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_> const, CAddressBookData> > >::find(boost::variant<CNoDestination, CKeyID, CScriptID, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_> const&) [71]
                0.08    1.52  930850/963023      CBitcoinAddress::Get() const [389]
                0.03    1.03  930542/1025379     CBitcoinAddress::~CBitcoinAddress() [484]
                0.07    0.77  930496/1160916     boost::variant<CNoDestination, CKeyID, CScriptID, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_>::~variant() [538]
                0.02    0.18  930660/96949719     CMutexLock<AnnotatedMixin<boost::recursive_mutex> >::CMutexLock(AnnotatedMixin<boost::recursive_mutex>&, char const*, char const*, int, bool) [52]
                0.09    0.08  930584/930597      QString::toStdString() const [1262]
                0.10    0.03  435584/435827      QString::QString() [1439]
                0.02    0.10  931309/97110659     CMutexLock<AnnotatedMixin<boost::recursive_mutex> >::~CMutexLock() [83]
                0.01    0.03  931733/950129      std::map<boost::variant<CNoDestination, CKeyID, CScriptID, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_>, CAddressBookData, std::less<boost::variant<CNoDestination, CKeyID, CScriptID, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_> >, std::allocator<std::pair<boost::variant<CNoDestination, CKeyID, CScriptID, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_> const, CAddressBookData> > >::end() [2296]
                0.01    0.01  495590/495590      std::_Rb_tree_iterator<std::pair<boost::variant<CNoDestination, CKeyID, CScriptID, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_> const, CAddressBookData> >::operator->() const [2923]
                0.02    0.00  929474/929474      std::_Rb_tree_iterator<std::pair<boost::variant<CNoDestination, CKeyID, CScriptID, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_> const, CAddressBookData> >::operator!=(std::_Rb_tree_iterator<std::pair<boost::variant<CNoDestination, CKeyID, CScriptID, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_, boost::detail::variant::void_> const, CAddressBookData> > const&) const [3130]
                0.02    0.00  495034/24299209     QString::fromStdString(std::string const&) [601]
-----------------------------------------------
                0.00    5.80   18395/948840      ReadKeyValue(CWallet*, CDataStream&, CDataStream&, CWalletScanState&, std::string&, std::string&) [44]
                0.07  293.29  930445/948840      AddressTableModel::labelForAddress(QString const&) const [4]
[5]     50.7    0.07  299.08  948840         CBitcoinAddress::CBitcoinAddress(std::string const&) [5]
                0.00  297.94  949944/949944      CBase58Data::SetString(std::string const&) [6]
                0.05    1.10  949931/1026400     CBase58Data::CBase58Data() [467]
-----------------------------------------------
                0.00  297.94  949944/949944      CBitcoinAddress::CBitcoinAddress(std::string const&) [5]
[6]     50.5    0.00  297.94  949944         CBase58Data::SetString(std::string const&) [6]
                0.15  297.79  948495/948495      CBase58Data::SetString(char const*, unsigned int) [7]
-----------------------------------------------
```
 

comment number: 41530010 
body: Maybe this is the part of interest:

```
-----------------------------------------------
                0.00    0.00      12/930979      TransactionTableModel::updateConfirmations() [2287]
                0.77   59.45  930967/930979      TransactionFilterProxy::filterAcceptsRow(int, QModelIndex const&) const [1]
[18]    10.2    0.77   59.45  930979         TransactionTableModel::index(int, int, QModelIndex const&) const [18]
                2.54   55.96 45668847/45668847     TransactionTablePriv::index(int) [19]
                0.47    0.48 22841271/22841273     QAbstractItemModel::createIndex(int, int, void*) const [563]
-----------------------------------------------
```

Note that the time to load the wallet initially is longer than the delays per block, so that's possibly what's showing up at the top of the list.
 

comment number: 274558816 
body: I believe the initial report here may have been fixed by #7846. 

209. bug report number : ['4070']
comment number: 40914474 
body: Is it possible that your ISP is sending RSTs to close the connections? What sort of connection do you have to the internet? Have you tried connecting via tor?
 

comment number: 40915831 
body: My ISP use Dual-Stack lite (DS-Lite). All my traffic is tunneled over IPv6 to the Carrier-Grade-NAT-Server of my ISP. This could be the reason. Now i searched the debug log about upnp and found out, it is not working. And GetMyExternalIP() gets the IP of my ISP's Shared IP all tunneld users get. 

So after my first test with onion net it work's like a charme :)
 

comment number: 42015916 
body: It indeed looks like IPv6 connections are being reset (by the peer, or the ISP?) rougly a second after the version message is received.
 

210. bug report number : ['4066']
comment number: 40690475 
body: So is this 0.9.0 or 0.9.1 and what shows your debug.log? Was it running before, did your PC crash, did you upgrade from an earlier version? Need more info...
 

comment number: 40707931 
body: this error happen in 091x64.

debug.log
Requesting initialize
Running AppInit2 in thread
2014-04-17 12:20:47 
2014-04-17 12:20:47 Bitcoin version v0.9.1.0-g026a939-beta (Tue, 8 Apr 2014 12:04:06 +0200)
2014-04-17 12:20:47 Using OpenSSL version OpenSSL 1.0.1g 7 Apr 2014
2014-04-17 12:20:47 Default data directory C:\Users\Fabio\AppData\Roaming\Bitcoin
2014-04-17 12:20:47 Using data directory d:\bitcoin\
2014-04-17 12:20:47 Using at most 125 connections (2048 file descriptors available)
2014-04-17 12:20:47 Using 8 threads for script verification
2014-04-17 12:20:47 Using wallet wallet.dat
2014-04-17 12:20:47 init message: Verificando carteira...
2014-04-17 12:20:47 dbenv.open LogDir=d:\bitcoin\database ErrorFile=d:\bitcoin\db.log
2014-04-17 12:20:47 Bound to [::]:8333
2014-04-17 12:20:47 Bound to 0.0.0.0:8333
2014-04-17 12:20:47 init message: Carregando índice de blocos...
2014-04-17 12:20:47 Opening LevelDB in d:\bitcoin\blocks\index
2014-04-17 12:20:47 Opened LevelDB successfully
2014-04-17 12:20:47 Opening LevelDB in d:\bitcoin\chainstate
2014-04-17 12:20:47 Opened LevelDB successfully
2014-04-17 12:20:47 LoadBlockIndexDB(): last block file = 0
2014-04-17 12:20:47 LoadBlockIndexDB(): transaction index disabled
2014-04-17 12:20:47 Initializing databases...
2014-04-17 12:20:47 Pre-allocating up to position 0x1000000 in blk00000.dat
2014-04-17 12:20:47 UpdateTip: new best=000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f  height=0  log2_work=32.000022  tx=1  date=2009-01-03 18:15:05 progress=0.000000
2014-04-17 12:20:47 init message: Verificando blocos...
2014-04-17 12:20:47  block index              47ms
2014-04-17 12:20:47 init message: Carregando carteira...
2014-04-17 12:20:47 nFileVersion = 90100
2014-04-17 12:20:47 Keys: 0 plaintext, 0 encrypted, 0 w/ metadata, 0 total
2014-04-17 12:20:47 Performing wallet upgrade to 60000
2014-04-17 12:20:47 keypool added key 1, size=1
2014-04-17 12:20:47 keypool added key 2, size=2
2014-04-17 12:20:47 keypool added key 3, size=3
2014-04-17 12:20:47 keypool added key 4, size=4
2014-04-17 12:20:47 keypool added key 5, size=5
2014-04-17 12:20:47 keypool added key 6, size=6
2014-04-17 12:20:47 keypool added key 7, size=7
2014-04-17 12:20:47 keypool added key 8, size=8
2014-04-17 12:20:47 keypool added key 9, size=9
2014-04-17 12:20:47 keypool added key 10, size=10
2014-04-17 12:20:47 keypool added key 11, size=11
2014-04-17 12:20:47 keypool added key 12, size=12
2014-04-17 12:20:48 keypool added key 13, size=13
2014-04-17 12:20:48 keypool added key 14, size=14
2014-04-17 12:20:48 keypool added key 15, size=15
2014-04-17 12:20:48 keypool added key 16, size=16
2014-04-17 12:20:48 keypool added key 17, size=17
2014-04-17 12:20:48 keypool added key 18, size=18
2014-04-17 12:20:48 keypool added key 19, size=19
2014-04-17 12:20:48 keypool added key 20, size=20
2014-04-17 12:20:48 keypool added key 21, size=21
2014-04-17 12:20:48 keypool added key 22, size=22
2014-04-17 12:20:48 keypool added key 23, size=23
2014-04-17 12:20:48 keypool added key 24, size=24
2014-04-17 12:20:48 keypool added key 25, size=25
2014-04-17 12:20:48 keypool added key 26, size=26
2014-04-17 12:20:48 keypool added key 27, size=27
2014-04-17 12:20:48 keypool added key 28, size=28
2014-04-17 12:20:48 keypool added key 29, size=29
2014-04-17 12:20:48 keypool added key 30, size=30
2014-04-17 12:20:48 keypool added key 31, size=31
2014-04-17 12:20:48 keypool added key 32, size=32
2014-04-17 12:20:48 keypool added key 33, size=33
2014-04-17 12:20:48 keypool added key 34, size=34
2014-04-17 12:20:48 keypool added key 35, size=35
2014-04-17 12:20:48 keypool added key 36, size=36
2014-04-17 12:20:48 keypool added key 37, size=37
2014-04-17 12:20:49 keypool added key 38, size=38
2014-04-17 12:20:49 keypool added key 39, size=39
2014-04-17 12:20:49 keypool added key 40, size=40
2014-04-17 12:20:49 keypool added key 41, size=41
2014-04-17 12:20:49 keypool added key 42, size=42
2014-04-17 12:20:49 keypool added key 43, size=43
2014-04-17 12:20:49 keypool added key 44, size=44
2014-04-17 12:20:49 keypool added key 45, size=45
2014-04-17 12:20:49 keypool added key 46, size=46
2014-04-17 12:20:49 keypool added key 47, size=47
2014-04-17 12:20:49 keypool added key 48, size=48
2014-04-17 12:20:49 keypool added key 49, size=49
2014-04-17 12:20:49 keypool added key 50, size=50
2014-04-17 12:20:49 keypool added key 51, size=51
2014-04-17 12:20:49 keypool added key 52, size=52
2014-04-17 12:20:49 keypool added key 53, size=53
2014-04-17 12:20:49 keypool added key 54, size=54
2014-04-17 12:20:49 keypool added key 55, size=55
2014-04-17 12:20:49 keypool added key 56, size=56
2014-04-17 12:20:49 keypool added key 57, size=57
2014-04-17 12:20:49 keypool added key 58, size=58
2014-04-17 12:20:49 keypool added key 59, size=59
2014-04-17 12:20:49 keypool added key 60, size=60
2014-04-17 12:20:49 keypool added key 61, size=61
2014-04-17 12:20:49 keypool added key 62, size=62
2014-04-17 12:20:50 keypool added key 63, size=63
2014-04-17 12:20:50 keypool added key 64, size=64
2014-04-17 12:20:50 keypool added key 65, size=65
2014-04-17 12:20:50 keypool added key 66, size=66
2014-04-17 12:20:50 keypool added key 67, size=67
2014-04-17 12:20:50 keypool added key 68, size=68
2014-04-17 12:20:50 keypool added key 69, size=69
2014-04-17 12:20:50 keypool added key 70, size=70
2014-04-17 12:20:50 keypool added key 71, size=71
2014-04-17 12:20:50 keypool added key 72, size=72
2014-04-17 12:20:50 keypool added key 73, size=73
2014-04-17 12:20:50 keypool added key 74, size=74
2014-04-17 12:20:50 keypool added key 75, size=75
2014-04-17 12:20:50 keypool added key 76, size=76
2014-04-17 12:20:50 keypool added key 77, size=77
2014-04-17 12:20:50 keypool added key 78, size=78
2014-04-17 12:20:50 keypool added key 79, size=79
2014-04-17 12:20:50 keypool added key 80, size=80
2014-04-17 12:20:50 keypool added key 81, size=81
2014-04-17 12:20:50 keypool added key 82, size=82
2014-04-17 12:20:50 keypool added key 83, size=83
2014-04-17 12:20:50 keypool added key 84, size=84
2014-04-17 12:20:50 keypool added key 85, size=85
2014-04-17 12:20:50 keypool added key 86, size=86
2014-04-17 12:20:50 keypool added key 87, size=87
2014-04-17 12:20:50 keypool added key 88, size=88
2014-04-17 12:20:51 keypool added key 89, size=89
2014-04-17 12:20:51 keypool added key 90, size=90
2014-04-17 12:20:51 keypool added key 91, size=91
2014-04-17 12:20:51 keypool added key 92, size=92
2014-04-17 12:20:51 keypool added key 93, size=93
2014-04-17 12:20:51 keypool added key 94, size=94
2014-04-17 12:20:51 keypool added key 95, size=95
2014-04-17 12:20:51 keypool added key 96, size=96
2014-04-17 12:20:51 keypool added key 97, size=97
2014-04-17 12:20:51 keypool added key 98, size=98
2014-04-17 12:20:51 keypool added key 99, size=99
2014-04-17 12:20:51 keypool added key 100, size=100
2014-04-17 12:20:51 keypool added key 101, size=101
2014-04-17 12:20:51 keypool reserve 1
2014-04-17 12:20:51 keypool keep 1
2014-04-17 12:20:51  wallet                 4484ms
2014-04-17 12:20:51 init message: Carregando endereços...
2014-04-17 12:20:51 ERROR: CAddrman::Read() : open failed
2014-04-17 12:20:51 Invalid or missing peers.dat; recreating
2014-04-17 12:20:51 Loaded 0 addresses from peers.dat  0ms
2014-04-17 12:20:51 mapBlockIndex.size() = 1
2014-04-17 12:20:51 nBestHeight = 0
2014-04-17 12:20:51 setKeyPool.size() = 100
2014-04-17 12:20:51 mapWallet.size() = 0
2014-04-17 12:20:51 mapAddressBook.size() = 1
2014-04-17 12:20:51 AddLocal([2001:0:5ef5:79fb:2875:17cc:f5f3:f7fe]:8333,1)
2014-04-17 12:20:51 ext-ip thread start
2014-04-17 12:20:51 init message: Carregamento terminado
2014-04-17 12:20:51 addcon thread start
2014-04-17 12:20:51 dnsseed thread start
2014-04-17 12:20:51 Loading addresses from DNS seeds (could take a while)
2014-04-17 12:20:51 opencon thread start
2014-04-17 12:20:51 msghand thread start
2014-04-17 12:20:51 dumpaddr thread start
2014-04-17 12:20:51 net thread start
2014-04-17 12:20:51 Initialization result: 1
2014-04-17 12:20:53 receive version message: /Satoshi:0.8.1/: version 70001, blocks=296318, us=189.45.8.85:49342, them=98.209.38.254:8333, peer=98.209.38.254:8333
2014-04-17 12:20:54 socket select error 0
2014-04-17 12:20:54 socket error accept failed: 10038
2014-04-17 12:20:54 socket error accept failed: 10038
2014-04-17 12:20:54 socket select error 0
2014-04-17 12:20:54 socket error accept failed: 10038
2014-04-17 12:20:54 socket error accept failed: 10038
2014-04-17 12:20:54 socket select error 0
 

comment number: 40708292 
body: Error 10038 (WSAENOTSOCK) means `Socket operation on nonsocket.`... have you set a proxy or are using any weird network configuration? Was 0.8.6 running without problems?
 

comment number: 40708565 
body: i update from 086x32 and they runs whit no problem
 

comment number: 40708864 
body: What about my other question? Can you try the 32-bit version.

Edit: Also can you add `-debug` to your bitcoin-qt.exe so we get a more detailed debug.log please.
 

comment number: 40724283 
body: same error
2014-04-17 15:05:51 socket error accept failed: 10038
 

comment number: 40725183 
body: If you are not able or willing to supply more details and refuse to give answers to all the questions I asked you (which we need to help you further), I'm unable to help you, sorry...
 

comment number: 40725929 
body: This assertion in itself only means that locked pages have leaked over run of the program.
(for example, it exited inexpectedly due to another problem)
It is itself not the cause of the exit.

What version of Windows is this?

I wonder if the networking problem is somehow IPv6 related:

```
  2014-04-17 12:20:51 AddLocal([2001:0:5ef5:79fb:2875:17cc:f5f3:f7fe]:8333,1)
```

Can you try starting with -onlynet=IPv4 ? Are you passing any command line options or bitcoin.conf settings related to external IPs / proxies and such? (as @diapolo already asks)
 

comment number: 40727166 
body: This is a clean install. I using Windows 8.1.

The log with -debug and -onlynet=IPv4
Requesting initialize
Running AppInit2 in thread
2014-04-17 15:28:55 

2014-04-17 15:28:55 Bitcoin version v0.9.1.0-g026a939-beta (Tue, 8 Apr 2014 12:04:06 +0200)
2014-04-17 15:28:55 Using OpenSSL version OpenSSL 1.0.1g 7 Apr 2014
2014-04-17 15:28:55 Default data directory C:\Users\Fabio\AppData\Roaming\Bitcoin
2014-04-17 15:28:55 Using data directory d:\bitcoin\
2014-04-17 15:28:55 Using at most 125 connections (2048 file descriptors available)
2014-04-17 15:28:55 Using 8 threads for script verification
2014-04-17 15:28:55 Using wallet wallet.dat
2014-04-17 15:28:55 init message: Verificando carteira...
2014-04-17 15:28:55 dbenv.open LogDir=d:\bitcoin\database ErrorFile=d:\bitcoin\db.log
2014-04-17 15:28:55 Bound to [::]:8333
2014-04-17 15:28:55 Bound to 0.0.0.0:8333
2014-04-17 15:28:55 init message: Carregando índice de blocos...
2014-04-17 15:28:55 Opening LevelDB in d:\bitcoin\blocks\index
2014-04-17 15:28:55 Opened LevelDB successfully
2014-04-17 15:28:55 Opening LevelDB in d:\bitcoin\chainstate
2014-04-17 15:28:55 Opened LevelDB successfully
2014-04-17 15:28:55 LoadBlockIndexDB(): last block file = 0
2014-04-17 15:28:55 LoadBlockIndexDB(): transaction index disabled
2014-04-17 15:28:55 Initializing databases...
2014-04-17 15:28:55 Pre-allocating up to position 0x1000000 in blk00000.dat
2014-04-17 15:28:55 Committing 0 changed transactions to coin database...
2014-04-17 15:28:55 UpdateTip: new best=000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f  height=0  log2_work=32.000022  tx=1  date=2009-01-03 18:15:05 progress=0.000000
2014-04-17 15:28:55 init message: Verificando blocos...
2014-04-17 15:28:55  block index              64ms
2014-04-17 15:28:55 init message: Carregando carteira...
2014-04-17 15:28:56 nFileVersion = 90100
2014-04-17 15:28:56 Keys: 0 plaintext, 0 encrypted, 0 w/ metadata, 0 total
2014-04-17 15:28:56 Performing wallet upgrade to 60000
2014-04-17 15:28:56 keypool added key 1, size=1
2014-04-17 15:28:56 keypool added key 2, size=2
2014-04-17 15:28:56 keypool added key 3, size=3
2014-04-17 15:28:56 keypool added key 4, size=4
2014-04-17 15:28:56 keypool added key 5, size=5
2014-04-17 15:28:56 keypool added key 6, size=6
2014-04-17 15:28:56 keypool added key 7, size=7
2014-04-17 15:28:56 keypool added key 8, size=8
2014-04-17 15:28:56 keypool added key 9, size=9
2014-04-17 15:28:56 keypool added key 10, size=10
2014-04-17 15:28:56 keypool added key 11, size=11
2014-04-17 15:28:56 keypool added key 12, size=12
2014-04-17 15:28:56 keypool added key 13, size=13
2014-04-17 15:28:56 keypool added key 14, size=14
2014-04-17 15:28:56 keypool added key 15, size=15
2014-04-17 15:28:56 keypool added key 16, size=16
2014-04-17 15:28:56 keypool added key 17, size=17
2014-04-17 15:28:56 keypool added key 18, size=18
2014-04-17 15:28:56 keypool added key 19, size=19
2014-04-17 15:28:56 keypool added key 20, size=20
2014-04-17 15:28:56 keypool added key 21, size=21
2014-04-17 15:28:56 keypool added key 22, size=22
2014-04-17 15:28:57 keypool added key 23, size=23
2014-04-17 15:28:57 keypool added key 24, size=24
2014-04-17 15:28:57 keypool added key 25, size=25
2014-04-17 15:28:57 keypool added key 26, size=26
2014-04-17 15:28:57 keypool added key 27, size=27
2014-04-17 15:28:57 keypool added key 28, size=28
2014-04-17 15:28:57 keypool added key 29, size=29
2014-04-17 15:28:57 keypool added key 30, size=30
2014-04-17 15:28:57 keypool added key 31, size=31
2014-04-17 15:28:57 keypool added key 32, size=32
2014-04-17 15:28:57 keypool added key 33, size=33
2014-04-17 15:28:57 keypool added key 34, size=34
2014-04-17 15:28:57 keypool added key 35, size=35
2014-04-17 15:28:57 keypool added key 36, size=36
2014-04-17 15:28:57 keypool added key 37, size=37
2014-04-17 15:28:57 keypool added key 38, size=38
2014-04-17 15:28:57 keypool added key 39, size=39
2014-04-17 15:28:57 keypool added key 40, size=40
2014-04-17 15:28:57 keypool added key 41, size=41
2014-04-17 15:28:57 keypool added key 42, size=42
2014-04-17 15:28:57 keypool added key 43, size=43
2014-04-17 15:28:57 keypool added key 44, size=44
2014-04-17 15:28:57 keypool added key 45, size=45
2014-04-17 15:28:57 keypool added key 46, size=46
2014-04-17 15:28:57 keypool added key 47, size=47
2014-04-17 15:28:57 keypool added key 48, size=48
2014-04-17 15:28:57 keypool added key 49, size=49
2014-04-17 15:28:58 keypool added key 50, size=50
2014-04-17 15:28:58 keypool added key 51, size=51
2014-04-17 15:28:58 keypool added key 52, size=52
2014-04-17 15:28:58 keypool added key 53, size=53
2014-04-17 15:28:58 keypool added key 54, size=54
2014-04-17 15:28:58 keypool added key 55, size=55
2014-04-17 15:28:58 keypool added key 56, size=56
2014-04-17 15:28:58 keypool added key 57, size=57
2014-04-17 15:28:58 keypool added key 58, size=58
2014-04-17 15:28:58 keypool added key 59, size=59
2014-04-17 15:28:58 keypool added key 60, size=60
2014-04-17 15:28:58 keypool added key 61, size=61
2014-04-17 15:28:58 keypool added key 62, size=62
2014-04-17 15:28:58 keypool added key 63, size=63
2014-04-17 15:28:58 keypool added key 64, size=64
2014-04-17 15:28:58 keypool added key 65, size=65
2014-04-17 15:28:58 keypool added key 66, size=66
2014-04-17 15:28:58 keypool added key 67, size=67
2014-04-17 15:28:58 keypool added key 68, size=68
2014-04-17 15:28:58 keypool added key 69, size=69
2014-04-17 15:28:58 keypool added key 70, size=70
2014-04-17 15:28:58 keypool added key 71, size=71
2014-04-17 15:28:58 keypool added key 72, size=72
2014-04-17 15:28:58 keypool added key 73, size=73
2014-04-17 15:28:58 keypool added key 74, size=74
2014-04-17 15:28:58 keypool added key 75, size=75
2014-04-17 15:28:58 keypool added key 76, size=76
2014-04-17 15:28:59 keypool added key 77, size=77
2014-04-17 15:28:59 keypool added key 78, size=78
2014-04-17 15:28:59 keypool added key 79, size=79
2014-04-17 15:28:59 keypool added key 80, size=80
2014-04-17 15:28:59 keypool added key 81, size=81
2014-04-17 15:28:59 keypool added key 82, size=82
2014-04-17 15:28:59 keypool added key 83, size=83
2014-04-17 15:28:59 keypool added key 84, size=84
2014-04-17 15:28:59 keypool added key 85, size=85
2014-04-17 15:28:59 keypool added key 86, size=86
2014-04-17 15:28:59 keypool added key 87, size=87
2014-04-17 15:28:59 keypool added key 88, size=88
2014-04-17 15:28:59 keypool added key 89, size=89
2014-04-17 15:28:59 keypool added key 90, size=90
2014-04-17 15:28:59 keypool added key 91, size=91
2014-04-17 15:28:59 keypool added key 92, size=92
2014-04-17 15:28:59 keypool added key 93, size=93
2014-04-17 15:28:59 keypool added key 94, size=94
2014-04-17 15:28:59 keypool added key 95, size=95
2014-04-17 15:28:59 keypool added key 96, size=96
2014-04-17 15:28:59 keypool added key 97, size=97
2014-04-17 15:28:59 keypool added key 98, size=98
2014-04-17 15:28:59 keypool added key 99, size=99
2014-04-17 15:28:59 keypool added key 100, size=100
2014-04-17 15:28:59 keypool added key 101, size=101
2014-04-17 15:28:59 keypool reserve 1
2014-04-17 15:28:59 keypool keep 1
2014-04-17 15:29:00  wallet                 4195ms
2014-04-17 15:29:00 init message: Carregando endereços...
2014-04-17 15:29:00 ERROR: CAddrman::Read() : open failed
2014-04-17 15:29:00 Invalid or missing peers.dat; recreating
2014-04-17 15:29:00 Loaded 0 addresses from peers.dat  0ms
2014-04-17 15:29:00 mapBlockIndex.size() = 1
2014-04-17 15:29:00 nBestHeight = 0
2014-04-17 15:29:00 setKeyPool.size() = 100
2014-04-17 15:29:00 mapWallet.size() = 0
2014-04-17 15:29:00 mapAddressBook.size() = 1
2014-04-17 15:29:00 ext-ip thread start
2014-04-17 15:29:00 init message: Carregamento terminado
2014-04-17 15:29:00 net thread start
2014-04-17 15:29:00 addcon thread start
2014-04-17 15:29:00 opencon thread start
2014-04-17 15:29:00 msghand thread start
2014-04-17 15:29:00 dnsseed thread start
2014-04-17 15:29:00 Loading addresses from DNS seeds (could take a while)
2014-04-17 15:29:00 Initialization result: 1
2014-04-17 15:29:00 dumpaddr thread start
2014-04-17 15:29:00 GUI: QMutex: destroying locked mutex
2014-04-17 15:29:00 Added 28 addresses from 178.18.90.41: 0 tried, 28 new
2014-04-17 15:29:00 trying connection 85.25.195.79:8333 lastseen=72.5hrs
2014-04-17 15:29:00 connected 85.25.195.79:8333
2014-04-17 15:29:00 send version message: version 70002, blocks=0, us=0.0.0.0:0, them=85.25.195.79:8333, peer=85.25.195.79:8333
2014-04-17 15:29:00 sending: version (101 bytes)
2014-04-17 15:29:01 received: version (101 bytes)
2014-04-17 15:29:01 sending: verack (0 bytes)
2014-04-17 15:29:01 sending: getaddr (0 bytes)
2014-04-17 15:29:01 Moving 85.25.195.79:8333 to tried
2014-04-17 15:29:01 receive version message: /Satoshi:0.9.1/: version 70002, blocks=296339, us=189.45.8.85:55593, them=85.25.195.79:8333, peer=85.25.195.79:8333
2014-04-17 15:29:01 socket select error 0
 

comment number: 40728011 
body: But it still quits immediately after startup?
It's strange, there are no fatal errors in that log.
 

comment number: 40730365 
body: he show the screen shot in the first post after +- 5 secs
 

211. bug report number : ['4064']
comment number: 40690627 
body: Can you show us a screenshot of your debug window, which lists current blocks downloaded and on the network?
 

comment number: 40755656 
body: some screenshots

Phillip Russell                          Mobile +1(901) 896-7445

On Thu, Apr 17, 2014 at 1:05 AM, P. Kaufmann notifications@github.comwrote:

> Can you show us a screenshot of your debug window, which lists current
> blocks downloaded and on the network?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/bitcoin/bitcoin/issues/4064#issuecomment-40690627
> .
 

comment number: 40860682 
body: I'm having similar issue.  Just upgraded from 8.6 to 9.0 to 9.1. Prior and after each upgrade, I was left with 3 weeks out of sync.  This sat overnight. and did not resolve.  My Debug window:
![image](https://cloud.githubusercontent.com/assets/7344210/2747669/4b94c5c2-c77c-11e3-9296-03a179219287.png)
Network Traffic:
![image](https://cloud.githubusercontent.com/assets/7344210/2747673/78106688-c77c-11e3-8587-83df68f4ed5d.png)

Bottom of Debug Log:
2014-04-19 04:35:14 ProcessBlock: ACCEPTED
2014-04-19 04:38:20 CheckForkWarningConditions: Warning: Large valid fork found
  forking the chain at height 292744 (00000000000000000971b9d01afdb3e2a344c719a7144457fde66ed280b9558c)
  lasting to height 296583 (0000000000000000397eef7324f6d6c888273264a6814d55f1a814260f4f7fb8).
Chain state database corruption likely.
2014-04-19 04:38:20 ProcessBlock: ACCEPTED

Complaints about upgrading start on 4/18.  Thanks!
 

comment number: 41997974 
body: If your chainstate is corrupted, a re-index will fix this (this can be done by starting the program with -reindex).
 

212. bug report number : ['4059']
comment number: 40505446 
body: That's what I'd expect...?
 

comment number: 40506187 
body: @luke-jr Unhandled exceptions are expected? Besides, as the GUI does have a 'first run' window for the user to select where to store bitcoin data - that could be invoked if ~/.bitcoin isn't accessible ;)
 

comment number: 40506655 
body: The data, not the config.
 

comment number: 40515518 
body: I made a patch once to improve datadir handling (https://github.com/bitcoin/bitcoin/pull/3640), it might solve this as well. Needs rebasing though...
 

213. bug report number : ['4051']
comment number: 40307961 
body: Can you gdb into the process and give us a traceback for the thread(s) that
hangs?

Also; anything unusual in the debug.log?
 

comment number: 40333263 
body: (gdb) info threads
  Id   Target Id         Frame
  20   Thread 0x7f75e7ca5700 (LWP 27738) "bitcoind" 0x00007f75e88840fe in pthread_cond_timedwait@@GLIBC_2.3.2 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
  19   Thread 0x7f75e74a4700 (LWP 27739) "bitcoin-scriptc" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2
    () from /lib/x86_64-linux-gnu/libpthread.so.0
  18   Thread 0x7f75e6ca3700 (LWP 27740) "bitcoin-scriptc" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2
    () from /lib/x86_64-linux-gnu/libpthread.so.0
  17   Thread 0x7f75e64a2700 (LWP 27741) "bitcoin-scriptc" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2
    () from /lib/x86_64-linux-gnu/libpthread.so.0
  16   Thread 0x7f75e5ca1700 (LWP 27742) "bitcoin-scriptc" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2
    () from /lib/x86_64-linux-gnu/libpthread.so.0
  15   Thread 0x7f75e54a0700 (LWP 27743) "bitcoin-scriptc" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2
    () from /lib/x86_64-linux-gnu/libpthread.so.0
  14   Thread 0x7f75e4c9f700 (LWP 27744) "bitcoin-scriptc" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2
    () from /lib/x86_64-linux-gnu/libpthread.so.0
  13   Thread 0x7f75cffff700 (LWP 27745) "bitcoin-scriptc" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2
    () from /lib/x86_64-linux-gnu/libpthread.so.0
  12   Thread 0x7f75b7c76700 (LWP 27944) "bitcoind" 0x000000000079cda0 in ?? ()
  11   Thread 0x7f75b5438700 (LWP 27952) "bitcoin-net" 0x00007f75e7d93763 in select ()
   from /lib/x86_64-linux-gnu/libc.so.6
  10   Thread 0x7f75b4c37700 (LWP 27953) "bitcoin-addcon" 0x00007f75e88840fe in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  9    Thread 0x7f759ffff700 (LWP 27954) "bitcoin-opencon" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2
    () from /lib/x86_64-linux-gnu/libpthread.so.0
  8    Thread 0x7f759f7fe700 (LWP 27955) "bitcoin-msghand" 0x00000000007ac93c in ?? ()
  7    Thread 0x7f759effd700 (LWP 27956) "bitcoin-dumpadd" 0x00007f75e88840fe in pthread_cond_timedwait@@GLIBC_2.3---Type <return> to continue, or q <return> to quit---
.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
  6    Thread 0x7f759e7fc700 (LWP 27957) "bitcoind" 0x00007f75e7d9aa93 in epoll_wait ()
   from /lib/x86_64-linux-gnu/libc.so.6
  5    Thread 0x7f759dffb700 (LWP 27958) "bitcoind" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
  4    Thread 0x7f759d7fa700 (LWP 27959) "bitcoind" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
  3    Thread 0x7f759cff9700 (LWP 27960) "bitcoind" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
  2    Thread 0x7f757ffff700 (LWP 27961) "bitcoin-wallet" 0x00007f75e88840fe in pthread_cond_timedwait@@GLIBC_2.3.2 () from /lib/x86_64-linux-gnu/libpthread.so.0
- 1    Thread 0x7f75e90bf740 (LWP 27737) "bitcoind" 0x00007f75e8883d84 in pthread_cond_wait@@GLIBC_2.3.2 ()
  from /lib/x86_64-linux-gnu/libpthread.so.0
 

comment number: 40333273 
body: 2014-04-14 04:55:14 received block 0000000000000000e02dc60c31549ba43aa7a4d0ab9eb8abda030b80e26264eb
2014-04-14 04:55:14 ERROR: ProcessBlock() : already have block 270572 0000000000000000e02dc60c31549ba43aa7a4d0ab9eb8abda030b80e26264eb
2014-04-14 04:55:14 received block 00000000000000019d2c06191a81d51027b2d738552ebf8566219301dc800621
2014-04-14 04:55:14 ERROR: ProcessBlock() : already have block 270559 00000000000000019d2c06191a81d51027b2d738552ebf8566219301dc800621
2014-04-14 04:55:14 received block 0000000000000002890e15edd582772649775bbe7618c7fb7c7930d590b307e6
2014-04-14 04:55:16 SetBestChain: new best=0000000000000002890e15edd582772649775bbe7618c7fb7c7930d590b307e6  height=270609  log2_work=74.061637  tx=27447111  date=2013-11-20 13:11:37 progress=0.541591
2014-04-14 04:55:16 ProcessBlock: ACCEPTED
2014-04-14 04:55:16 received block 0000000000000002890e15edd582772649775bbe7618c7fb7c7930d590b307e6
2014-04-14 04:55:16 ERROR: ProcessBlock() : already have block 270609 0000000000000002890e15edd582772649775bbe7618c7fb7c7930d590b307e6
2014-04-14 04:55:16 received block 0000000000000001bc303de18d5fc8f3516d6226241a21164c7523914bc0410f
2014-04-14 04:55:16 ERROR: ProcessBlock() : already have block 270567 0000000000000001bc303de18d5fc8f3516d6226241a21164c7523914bc0410f
2014-04-14 04:55:16 received block 00000000000000057f124916e87fee0c7c5158f6395dba4830806644d91bada7
2014-04-14 04:55:16 ERROR: ProcessBlock() : already have block 270573 00000000000000057f124916e87fee0c7c5158f6395dba4830806644d91bada7
2014-04-14 04:55:16 received block 0000000000000002e1ce99bab8a494cda6000dce4b89fc8f8e6515a23d166818
2014-04-14 04:55:19 SetBestChain: new best=0000000000000002e1ce99bab8a494cda6000dce4b89fc8f8e6515a23d166818  height=270610  log2_work=74.061829  tx=27447443  date=2013-11-20 13:16:48 progress=0.541605
2014-04-14 04:55:19 ProcessBlock: ACCEPTED
2014-04-14 04:55:19 received block 0000000000000002e17bc0a5590b0608fa72d0e3a336c2d68a90c5d955716e93
2014-04-14 04:55:19 ERROR: ProcessBlock() : already have block 270568 0000000000000002e17bc0a5590b0608fa72d0e3a336c2d68a90c5d955716e93
2014-04-14 04:55:19 received block 00000000000000058813ca25de2d2d8821c4ae39dcdced5f63609c48d59ad0ce
2014-04-14 04:55:19 ERROR: ProcessBlock() : already have block 270560 00000000000000058813ca25de2d2d8821c4ae39dcdced5f63609c48d59ad0ce
^C
 

comment number: 40333310 
body: Above is the output when i list thread in gdb and the debug.log. 
hope this can help, i am happy to provide more info, thanks.
 

214. bug report number : ['4034']
comment number: 39983897 
body: Can you reliably reproduce this? I have a candidate fix.
 

comment number: 41998277 
body: @Joukehofman can you test if #4037 fixes this issue?
 

comment number: 41999013 
body: I talked with gmaxwell on IRC about this issue and it is not easy to reproduce I am afraid. But if I remember correctly we also came to the conclusion that this commit may not have corrected this issue. IRC-logs: http://bitcoinstats.com/irc/bitcoin-dev/logs/2014/04/09#l1397062552
 

comment number: 371703040 
body: Seems like either the issue is fixed or at least hasn't provoked any discussion for nearly 4 years, closing now... 

215. bug report number : ['4013']
comment number: 39675602 
body: I've managed to replicate this, the config file parser seems to require each key to have a value (if it doesn't Bitcoin crashes) and it doesn't recognise true or any string as being true.

"disablewallet=n" where n is an integer and not 0 disables the wallet.
 

comment number: 39696746 
body: It indeed doesn't recognize 'true'. Values of such options must be 0 or 1.

Sounds like a bug in the config file parser that it crashes on bare `disablewallet`.
 

216. bug report number : ['4003']
comment number: 39633076 
body: This is very strange. Why would it be unable to open the database file but only when you shut down?

In any case, can you try (may need db4.8-util or similar package):

``` bash
cd ~/.bitcoin
mv wallet.dat wallet.dat.backup
db4.8_dump wallet.dat.backup | db4.8_load wallet.dat
```
 

comment number: 39646212 
body: The first time I noticed the error was shortly after using rsync to copy my whole home directory over to a new laptop.  The one I was copying from was running bitcoin-qt at the time.  I figured that was a bad idea, so went to shut bitcoin-qt down and re-run the sync, and it was then that I saw the error message.  I was wondering if the problem could have been caused by rsync reading the wallet file while it was open.  But as I say, the laptop had frozen on resume shortly before this as well.

I restarted bitcoin, it came up just fine, but again when I went to shut it down, I saw the same error again.

And interestingly, even after copying everything over to the new laptop, I saw the same error on the new laptop the first time I ran it.  But just this morning I was able to shut it down without the error, so it looks like the problem eventually resolved itself.

Here's a screenshot I took the first time the error happened.  Both dialogs are on the screen at the same time.

![screenshot - 14-04-04 - 07 15 45 am](https://cloud.githubusercontent.com/assets/573356/2623414/1089aaea-bced-11e3-8d11-40d46c9de99b.png)

I should probably mention that I'm using libdb5.3++-dev and had to use a ./configure flag for non-compatible wallets, but I've been using that for a long time.

Running the dump/load commands completes without error (on the new laptop where the problem is already apparently fixed), and makes the wallet considerably smaller:

```
$ cp ~/.bitcoin/wallet.dat wallet.dat.before
$ db5.3_dump wallet.dat.before | db5.3_load wallet.dat.after
$ ls -lh wallet.dat*
-rw-r--r-- 1 chris chris 140M Apr  5 11:11 wallet.dat.after
-rw------- 1 chris chris 151M Apr  5 11:10 wallet.dat.before
$ 
```

I'll try it on the old laptop where the error presumably still happens.
 

comment number: 39646679 
body: On the old laptop:

```
$ db5.3_dump wallet.dat.before | db5.3_load wallet.dat.after
$ ls -l wallet.dat.*
-rw-r--r-- 1 chris chris 146464768 Apr  5 11:19 wallet.dat.after
-rw------- 1 chris chris 157814784 Apr  5 11:17 wallet.dat.before
$ 
```

Then I ran bitcoin-qt on the 'before' version of the wallet, and it did still crash on shutdown.  It definitely loaded up, showed the wallet balance, and started catching up with the blockchain.

![screenshot - 14-04-05 - 11 27 12 am](https://cloud.githubusercontent.com/assets/573356/2623455/1b832216-bcf0-11e3-8a26-47191ae63bb3.png)
 

comment number: 39646994 
body: Running bitcoin-qt with the 'wallet.dat.after' file created using those db util commands fixed the problem.  I can now start and close the wallet without error messages.
 

217. bug report number : ['3997']
comment number: 39379535 
body: This looks weird. Could be a synchronization problem.
 

comment number: 39379870 
body: I also ran a:

```
(gdb) thread apply all bt full
```

but the output contains a lot of binary data, so I'm not sure it's safe to post it here.
 

comment number: 39401482 
body: Those dust transactions don't look very typical. Could it be related to those?
 

comment number: 39410510 
body: The wallet.dat is an old "hot wallet" from the Just-Dice server.  I retired it when it got too big.  It's about 157MB.  I don't know if any of that is relevant.

Restarting bitcoin-qt went fine however.
 

comment number: 40124253 
body: I just had the same crash again.

Here's the backtrace:

```
[New Thread 0x7fff86f5d700 (LWP 20786)]
[Thread 0x7fffbccc7700 (LWP 20776) exited]
[New Thread 0x7fff8670c700 (LWP 20787)]

Program received signal SIGSEGV, Segmentation fault.
CMerkleTx::GetDepthInMainChainINTERNAL (this=this@entry=0x7fffab600f90, 
    pindexRet=@0x7fffffffd448: 0x555556bb0120) at main.cpp:884
884     if (!pindex || !chainActive.Contains(pindex))
(gdb) where
#0  CMerkleTx::GetDepthInMainChainINTERNAL (this=this@entry=0x7fffab600f90, 
    pindexRet=@0x7fffffffd448: 0x555556bb0120) at main.cpp:884
#1  0x000055555571dca6 in CMerkleTx::GetDepthInMainChain (
    this=this@entry=0x7fffab600f90, pindexRet=@0x7fffffffd448: 0x555556bb0120)
    at main.cpp:901
#2  0x00005555556b632d in GetDepthInMainChain (this=0x7fffab600f90)
    at ../../src/main.h:466
#3  CWalletTx::IsTrusted (this=this@entry=0x7fffab600f90)
    at ../../src/wallet.h:665
#4  0x00005555556b40cd in TransactionRecord::updateStatus (
    this=this@entry=0x5555571f9720, wtx=...) at transactionrecord.cpp:167
#5  0x00005555556933cd in TransactionTablePriv::index (this=<optimized out>, 
    idx=idx@entry=29366) at transactiontablemodel.cpp:201
#6  0x000055555569231e in TransactionTableModel::index (this=0x555556a62f70, 
    row=29366, column=0, parent=...) at transactiontablemodel.cpp:615
#7  0x000055555568f398 in TransactionFilterProxy::filterAcceptsRow (this=
    0x5555572e0940, sourceRow=29366, sourceParent=...)
    at transactionfilterproxy.cpp:33
```

and here's the debug.log:

```
2014-04-10 18:43:25 Bitcoin version v0.9.0-1-gd824858-beta (2014-03-20 09:19:05 -0700)
2014-04-10 18:43:25 Using OpenSSL version OpenSSL 1.0.1e 11 Feb 2013
2014-04-10 18:43:25 Default data directory /home/chris/.bitcoin
2014-04-10 18:43:25 Using data directory /home/chris/.bitcoin
2014-04-10 18:43:25 Using at most 125 connections (1024 file descriptors available)
2014-04-10 18:43:25 Using 4 threads for script verification
2014-04-10 18:43:25 Using wallet wallet.dat
2014-04-10 18:43:25 init message: Verifying wallet...
2014-04-10 18:43:25 dbenv.open LogDir=/home/chris/.bitcoin/database ErrorFile=/home/chris/.bitcoin/db.log
2014-04-10 18:43:31 Bound to [::]:8333
2014-04-10 18:43:31 Bound to 0.0.0.0:8333
2014-04-10 18:43:31 init message: Loading block index...
2014-04-10 18:43:31 Opening LevelDB in /home/chris/.bitcoin/blocks/index
2014-04-10 18:43:31 Opened LevelDB successfully
2014-04-10 18:43:31 Opening LevelDB in /home/chris/.bitcoin/chainstate
2014-04-10 18:43:33 Opened LevelDB successfully
2014-04-10 18:43:39 LoadBlockIndexDB(): last block file = 91
2014-04-10 18:43:39 LoadBlockIndexDB(): last block file info: CBlockFileInfo(blocks=557, size=134128178, heights=294301...294855, time=2014-04-05...2014-04-08)
2014-04-10 18:43:39 LoadBlockIndexDB(): transaction index disabled
2014-04-10 18:43:39 LoadBlockIndexDB(): hashBestChain=00000000000000001ace9b38d37f391b04e9e094dd22e2f141a6d01b955907b0 height=294855 date=2014-04-08 23:28:27 progress=0.991102
2014-04-10 18:43:39 init message: Verifying blocks...
2014-04-10 18:43:39 Verifying last 288 blocks at level 2
2014-04-10 18:43:51 No coin database inconsistencies in last 0 blocks (0 transactions)
2014-04-10 18:43:51  block index           20269ms
2014-04-10 18:43:51 init message: Loading wallet...
2014-04-10 18:46:18 nFileVersion = 90000
2014-04-10 18:46:18 Keys: 36667 plaintext, 0 encrypted, 0 w/ metadata, 36667 total
2014-04-10 18:46:19  wallet               147566ms
2014-04-10 18:46:19 init message: Loading addresses...
2014-04-10 18:46:19 Loaded 18216 addresses from peers.dat  151ms
2014-04-10 18:46:19 mapBlockIndex.size() = 295183
2014-04-10 18:46:19 nBestHeight = 294855
2014-04-10 18:46:19 setKeyPool.size() = 4996
2014-04-10 18:46:19 mapWallet.size() = 30434
2014-04-10 18:46:19 mapAddressBook.size() = 19485
2014-04-10 18:46:19 ext-ip thread start
2014-04-10 18:46:19 dnsseed thread start
2014-04-10 18:46:19 Loading addresses from DNS seeds (could take a while)
2014-04-10 18:46:19 net thread start
2014-04-10 18:46:19 addcon thread start
2014-04-10 18:46:19 opencon thread start
2014-04-10 18:46:19 msghand thread start
2014-04-10 18:46:19 dumpaddr thread start
2014-04-10 18:46:19 init message: Done loading
2014-04-10 18:46:19 ERROR: AcceptToMemoryPool : nonstandard transaction: dust
2014-04-10 18:46:20 ERROR: AcceptToMemoryPool : nonstandard transaction: dust
2014-04-10 18:46:20 GetMyExternalIP() received [a.b.c.d] a.b.c.d:0
2014-04-10 18:46:20 GetMyExternalIP() returned a.b.c.d
2014-04-10 18:46:20 AddLocal(a.b.c.d:8333,4)
2014-04-10 18:46:20 ext-ip thread exit
2014-04-10 18:46:20 ERROR: AcceptToMemoryPool : nonstandard transaction: dust
2014-04-10 18:46:20 ERROR: AcceptToMemoryPool : nonstandard transaction: dust
2014-04-10 18:46:20 ERROR: AcceptToMemoryPool : nonstandard transaction: dust
2014-04-10 18:46:20 Initialization result: 1
2014-04-10 18:46:21 receive version message: /Satoshi:0.8.5/: version 70001, blocks=295149, us=a.b.c.d:41277, them=e.f.g.h:8333, peer=e.f.g.h:8333
2014-04-10 18:46:21 Added time data, samples 2, offset +2 (+0 minutes)
2014-04-10 18:46:26 Leaving block file 91: CBlockFileInfo(blocks=557, size=134128178, heights=294301...294855, time=2014-04-05...2014-04-08)
2014-04-10 18:46:26 Pre-allocating up to position 0x1000000 in blk00092.dat
2014-04-10 18:46:28 Pre-allocating up to position 0x100000 in rev00092.dat
2014-04-10 18:46:28 UpdateTip: new best=00000000000000005bc86c2eb08ffb68d420c895b59cc98019cad366e54ad945  height=294856  log2_work=77.845013  tx=36485528  date=2014-04-08 23:55:49 progress=0.991186
Requesting initialize
Running AppInit2 in thread
2014-04-10 18:47:21 
```

There's mention of dust transactions again.
 

comment number: 40173160 
body: Bumping this to high priority.

Given the backtrace I doubt it has anything to do with dust transactions, though this is of course not impossible (possible scenario: wallet tries to accept unconfirmed dust transaction to mempool, this fails, wallet keeps some pointer at NULL. Gdb is not very helpful there, note that the value of 'this' is conveniently not shown in the backtrace).

But more likely still is that there is a small time at which chainActive is invalid. I wonder if we acquire the right mutexes there.
 

comment number: 40272965 
body: Is there anything I can usefully type at the (gdb) prompt at the point of the crash?  I have the prompt in a terminal now, having seen the crash for a 3rd time.

I tried a few things, but I've no idea what I'm doing (as is apparent from the log below):

```
Program received signal SIGSEGV, Segmentation fault.
CMerkleTx::GetDepthInMainChainINTERNAL (this=this@entry=0x7fffaf4ca830, 
    pindexRet=@0x7fffffffd348: 0x7fffffff0120) at main.cpp:884
884     if (!pindex || !chainActive.Contains(pindex))
(gdb) where
#0  CMerkleTx::GetDepthInMainChainINTERNAL (this=this@entry=0x7fffaf4ca830, 
    pindexRet=@0x7fffffffd348: 0x7fffffff0120) at main.cpp:884
#1  0x00005555556d2d84 in CMerkleTx::GetDepthInMainChain (
    this=this@entry=0x7fffaf4ca830, pindexRet=@0x7fffffffd348: 0x7fffffff0120)
    at main.cpp:901
(gdb) p pindex
$1 = (CBlockIndex *) 0x7fffce1d27c0
(gdb) p *pindex
$2 = {phashBlock = 0x7fffce1d2870, pprev = 0x7fffce76e280, nHeight = 278865, 
  nFile = 67, nDataPos = 35780181, nUndoPos = 4688225, 
  nChainWork = {<base_uint<256u>> = {pn = {3983914728, 3086537670, 2818, 0, 
        0, 0, 0, 0}}, <No data fields>}, nTx = 657, nChainTx = 30494343, 
  nStatus = 29, nVersion = 2, hashMerkleRoot = {<base_uint<256u>> = {pn = {
        2507042385, 3851559055, 2920226300, 340783779, 2588707176, 
        2242370894, 447711919, 1858711587}}, <No data fields>}, 
  nTime = 1388979213, nBits = 419628831, nNonce = 3562446643, nSequenceId = 0}
(gdb) p this
$3 = (const CMerkleTx * const) 0x7fffaf4ca830
(gdb) p *this
$4 = {<CTransaction> = {static nMinTxFee = 10000, 
    static nMinRelayTxFee = 1000, static CURRENT_VERSION = 1, nVersion = 1, 
    vin = {<std::_Vector_base<CTxIn, std::allocator<CTxIn> >> = {
        _M_impl = {<std::allocator<CTxIn>> = {<__gnu_cxx::new_allocator<CTxIn>> = {<No data fields>}, <No data fields>}, _M_start = 0x7fffaf4ca960, 
          _M_finish = 0x7fffaf4ca9f0, 
          _M_end_of_storage = 0x7fffaf4ca9f0}}, <No data fields>}, 
    vout = {<std::_Vector_base<CTxOut, std::allocator<CTxOut> >> = {
        _M_impl = {<std::allocator<CTxOut>> = {<__gnu_cxx::new_allocator<CTxOut>> = {<No data fields>}, <No data fields>}, _M_start = 0x7fffaf4caa70, 
          _M_finish = 0x7fffaf4caa90, 
          _M_end_of_storage = 0x7fffaf4caa90}}, <No data fields>}, 
    nLockTime = 0}, hashBlock = {<base_uint<256u>> = {pn = {1286607707, 
        3584892090, 1270973470, 1740750181, 949783574, 2764214055, 0, 
        0}}, <No data fields>}, 
  vMerkleBranch = {<std::_Vector_base<uint256, std::allocator<uint256> >> = {
      _M_impl = {<std::allocator<uint256>> = {<__gnu_cxx::new_allocator<uint256>> = {<No data fields>}, <No data fields>}, _M_start = 0x7fffaf4caaa0, 
        _M_finish = 0x7fffaf4cabe0, 
        _M_end_of_storage = 0x7fffaf4cabe0}}, <No data fields>}, 
  nIndex = 587, fMerkleVerified = true}
(gdb) p chainActive
$5 = {
  vChain = {<std::_Vector_base<CBlockIndex*, std::allocator<CBlockIndex*> >> = {
      _M_impl = {<std::allocator<CBlockIndex*>> = {<__gnu_cxx::new_allocator<CBlockIndex*>> = {<No data fields>}, <No data fields>}, _M_start = 0x7fff959fe900, 
        _M_finish = 0x7fff95c3f6c8, 
        _M_end_of_storage = 0x7fff95e80480}}, <No data fields>}}
(gdb) p chainActive.Contains(pindex)
Cannot evaluate function -- may be inlined
(gdb) p pindex->nHeight
$6 = 278865
(gdb) p (*chainActive)[278865]
Cannot resolve function operator* to any overloaded instance
(gdb) p (chainActive)[278865]
Could not find operator[].
(gdb) p chainActive[278865]
Could not find operator[].
(gdb) p *chainActive[278865]
Could not find operator[].
(gdb) p chainActive.vChain
$7 = {<std::_Vector_base<CBlockIndex*, std::allocator<CBlockIndex*> >> = {
    _M_impl = {<std::allocator<CBlockIndex*>> = {<__gnu_cxx::new_allocator<CBlockIndex*>> = {<No data fields>}, <No data fields>}, 
      _M_start = 0x7fff959fe900, _M_finish = 0x7fff95c3f6c8, 
      _M_end_of_storage = 0x7fff95e80480}}, <No data fields>}
(gdb) p chainActive.vChain[278865]
Could not find operator[].
(gdb) p *(chainActive.vChain)
Cannot resolve function operator* to any overloaded instance
(gdb) p chainActive.vChain.size()
Cannot evaluate function -- may be inlined
(gdb) p chainActive.vChain->size()
Cannot resolve method std::vector<CBlockIndex*, std::allocator<CBlockIndex*> >::size to any overloaded instance
(gdb) p chainActive.vChain
$8 = {<std::_Vector_base<CBlockIndex*, std::allocator<CBlockIndex*> >> = {
    _M_impl = {<std::allocator<CBlockIndex*>> = {<__gnu_cxx::new_allocator<CBlockIndex*>> = {<No data fields>}, <No data fields>}, 
      _M_start = 0x7fff959fe900, _M_finish = 0x7fff95c3f6c8, 
      _M_end_of_storage = 0x7fff95e80480}}, <No data fields>}
(gdb) p chainActive.vChain.empty()
Cannot evaluate function -- may be inlined
```
 

comment number: 40280871 
body: Someone on IRC also reported crashes at startup with 0.9.0, at the first updateTip with a large wallet. No traceback, but is likely to be the same issue.
 

comment number: 40281168 
body: @dooglus as you're compiling the source yourself, can you try replacing line 196 in transactiontablemodel.cpp from:

``` c++
LOCK(wallet->cs_wallet);
```

to 

``` c++
LOCK2(cs_main, wallet->cs_wallet);
```

I'm fairly confident that that will solve this race.
(if this works, I'm going to add lockheld assertions over the place to see if there are other cases where, indirectly, main chainActive.\* is called without the main lock)
 

comment number: 40285200 
body: I sure can.

Should I just quit the previous bitcoin-qt?  It's currently at a (gdb) prompt waiting for you to give me stuff to ask it.

Also, note that it took me maybe 10 attempts yesterday to get the crash to happen, so if it doesn't happen today it doesn't necessarily mean the bug is fixed.
 

comment number: 40285395 
body: Yes, let's quit and re-try. I wouldn't know how to check this out on the gdb prompt. Likely the chainActive data structure is inconsistent in some way, but it takes knowledge about the internal working of libstdc++ to find out exactly what. It's nothing obvious, and if gdb hasn't optimized all the debugging info away...
 

comment number: 40285827 
body: I made the change you suggested, rebuilt, and it crashed the very first time I ran it.

The backtrace is a little different.  Whereas before, `CWalletTx::IsTrusted` (wallet.h:665, #3 in the trace) was being called from `TransactionRecord::updateStatus` (transactionrecord.cpp:167), now it is called from `CWallet::GetBalance` (walletmodel.cpp:66)

Here's the new backtrace:

```
#0  CMerkleTx::GetDepthInMainChainINTERNAL (this=this@entry=0x7fffb198b8f0, 
    pindexRet=@0x7fffffffd628: 0x7fffda16cd90) at main.cpp:884
#1  0x00005555556d2c94 in CMerkleTx::GetDepthInMainChain (
    this=this@entry=0x7fffb198b8f0, pindexRet=@0x7fffffffd628: 0x7fffda16cd90)
    at main.cpp:901
#2  0x0000555555676f0d in GetDepthInMainChain (this=0x7fffb198b8f0)
    at ../../src/main.h:466
#3  CWalletTx::IsTrusted (this=0x7fffb198b8f0) at ../../src/wallet.h:665
#4  0x00005555557bbebc in CWallet::GetBalance (this=0x7fffb0f3ec80)
    at wallet.cpp:966
#5  0x000055555560bf19 in WalletModel::getBalance (this=this@entry=
    0x5555567590b0, coinControl=coinControl@entry=0x0) at walletmodel.cpp:66
#6  0x000055555564ce91 in SendCoinsDialog::setModel (this=0x5555571d7850, 
    model=model@entry=0x5555567590b0) at sendcoinsdialog.cpp:93
#7  0x000055555561ebb1 in WalletView::setWalletModel (this=0x5555571982a0, 
    walletModel=0x5555567590b0) at walletview.cpp:113
#8  0x000055555560ae17 in WalletFrame::addWallet (this=0x555556279540, 
    name=..., walletModel=walletModel@entry=0x5555567590b0)
    at walletframe.cpp:48
#9  0x00005555555d0129 in BitcoinGUI::addWallet (this=<optimized out>, 
    name=..., walletModel=walletModel@entry=0x5555567590b0)
    at bitcoingui.cpp:428
#10 0x00005555555bf4d7 in BitcoinApplication::initializeResult (
    this=this@entry=0x7fffffffe2e0, retval=1) at bitcoin.cpp:400
#11 0x00005555555bf88f in BitcoinApplication::qt_static_metacall (
    _o=0x7fffffffe2e0, _id=<optimized out>, _a=0x7fffb02f0170, 
    _c=<optimized out>) at bitcoin.moc:169
#12 0x00007ffff61f3dce in QObject::event(QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#13 0x00007ffff6a58ea3 in QApplication::event(QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#14 0x00007ffff6a53dfc in QApplicationPrivate::notify_helper(QObject*, QEvent*) () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#15 0x00007ffff6a5a470 in QApplication::notify(QObject*, QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#16 0x00007ffff61db8bd in QCoreApplication::notifyInternal(QObject*, QEvent*)
    () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#17 0x00007ffff61dee1f in QCoreApplicationPrivate::sendPostedEvents(QObject*, int, QThreadData*) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
```
 

comment number: 40310177 
body: It is promising that the crash now happens in another place where the same problem exists.

Would be safest to replace all places where the GUI locks the wallet by LOCK2(main ,wallet).

Edit: hm, changing in it the GUI is not enough: CWallet::GetBalance itself locks the wallet, but not main, it should be changed as well...
 

comment number: 40497730 
body: #4058 likely solves this issue
 

comment number: 41201250 
body: I'm still running the version that you mentioned 8 days ago:

> #4058 likely solves this issue

and just had it lock up:

```
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 50
5735c6b22004430f5e2f62933153b5a821417389b89fcdf7bf3c50f4a8a01fd8
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 50
01d409dac77df5a9ba0e6793dac1e77109d23985eec0d68a638190862645a1c9
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 50
error: {"code":-4,"message":"Insufficient funds"}
chris@chris:~/.bitcoin$ bc listunspent
[lots of output]
chris@chris:~/.bitcoin$ bc listunspent
[no output, just hung]
```

The end of debug.log shows:

```
2014-04-23 19:00:50 ERROR: AcceptToMemoryPool : inputs already spent
2014-04-23 19:02:11 ResendWalletTransactions()
2014-04-23 19:02:11 Relaying wtx 0f2b67658e43d518ad37e2d569fcbc414d90487f2ed7e10b442f8c9a2bee9b63
2014-04-23 19:02:11 Relaying wtx 3cc79db066abc7a5582669fbd5b0c855975c4f2537ece52370c2c6eb099f5b85
2014-04-23 19:02:11 Relaying wtx d416993c56c2e7d9e753f902ce04ce1b8c31b8cfc14fe8e17603b36cdfadeedc
```

I don't know if that means we're acquiring too many locks now, and trying to acquire the same one twice, causing a deadlock.

I hit control-c in the gdb window, and got:

```
Program received signal SIGINT, Interrupt.
__lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
135 ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S: No such file or directory.
(gdb) where
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x0000555555664d54 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at ../../src/sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at ../../src/sync.h:118
#7  CMutexLock (fTry=false, nLine=196, 
    pszFile=0x555555afb29d "transactiontablemodel.cpp", 
    pszName=<optimized out>, mutexIn=..., this=<synthetic pointer>)
    at ../../src/sync.h:139
#8  TransactionTablePriv::index (this=0x5555566c70d0, idx=idx@entry=23040)
    at transactiontablemodel.cpp:196
#9  0x0000555555663a70 in TransactionTableModel::index (this=0x555556859770, 
    row=23040, column=0, parent=...) at transactiontablemodel.cpp:615
#10 0x0000555555660d5d in TransactionFilterProxy::filterAcceptsRow (this=
    0x555557aad020, sourceRow=23040, sourceParent=...)
    at transactionfilterproxy.cpp:33
```

I ran a 'where' on all threads, and got this.  Hopefully it will tell you why it's frozen:

```
(gdb) thread apply all where

Thread 25 (Thread 0x7fff7d799700 (LWP 6128)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x0000555555849bfb in BGThread (this=0x7fffc81614e0)
    at util/env_posix.cc:563
#2  leveldb::(anonymous namespace)::PosixEnv::BGThreadWrapper (
    arg=0x7fffc81614e0) at util/env_posix.cc:510
#3  0x00007ffff58c9182 in start_thread (arg=0x7fff7d799700)
    at pthread_create.c:312
#4  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 24 (Thread 0x7fff82da3700 (LWP 6126)):
#0  pthread_cond_timedwait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S:238
#1  0x00007ffff754bacc in boost::condition_variable::do_wait_until(boost::unique_lock<boost::mutex>&, timespec const&) ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#2  0x00007ffff75484ba in boost::this_thread::hiden::sleep_for(timespec const&) () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#3  0x0000555555709924 in sleep_for (ns=<synthetic pointer>)
    at /usr/include/boost/thread/pthread/thread_data.hpp:235
#4  boost::this_thread::sleep_for<long, boost::ratio<1l, 1000l> > (d=...)
    at /usr/include/boost/thread/v2/thread.hpp:53
#5  0x00005555557e19d9 in MilliSleep (n=500) at util.h:97
#6  ThreadFlushWalletDB (strFile=...) at walletdb.cpp:782
#7  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#8  0x00007ffff58c9182 in start_thread (arg=0x7fff82da3700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 23 (Thread 0x7fff8b7ae700 (LWP 6125)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x000055555573b1a6 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at sync.h:118
#7  CMutexLock (fTry=false, nLine=852, 
    pszFile=0x555555b4f980 "rpcserver.cpp", pszName=<optimized out>, 
    mutexIn=..., this=<synthetic pointer>) at sync.h:139
#8  CRPCTable::execute (this=this@entry=0x555555ebd9e0 <tableRPC>, 
    strMethod=..., params=...) at rpcserver.cpp:852
#9  0x000055555573dd78 in ServiceConnection (conn=conn@entry=0x7fff9c0018f0)
    at rpcserver.cpp:797
#10 0x000055555573eb50 in RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > (acceptor=..., context=..., 
    fUseSSL=<optimized out>, conn=0x7fff9c0018f0, error=...)
    at rpcserver.cpp:495
#11 0x000055555574383a in operator()<void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, const boost::system::error_code&), boost::_bi::list1<const boost::system::error_code&> > (
    f=@0x7fff8b7adbf0: 0x55555573e940 <RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> >(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&)>, a=<synthetic pointer>, 
    this=0x7fff8b7adbf8) at /usr/include/boost/bind/bind.hpp:525
#12 operator()<boost::system::error_code> (a1=..., this=0x7fff8b7adbf0)
    at /usr/include/boost/bind/bind_template.hpp:47
#13 operator() (this=0x7fff8b7adbf0)
    at /usr/include/boost/asio/detail/bind_handler.hpp:47
#14 asio_handler_invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code> > (
    function=<error reading variable: access outside bounds of object referenced via synthetic pointer>)
    at /usr/include/boost/asio/handler_invoke_hook.hpp:64
#15 invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code>, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > > (context=..., function=...)
    at /usr/include/boost/asio/detail/handler_invoke_helpers.hpp:37
#16 boost::asio::detail::reactive_socket_accept_op<boost::asio::basic_socket<boost::asio::ip::tcp, boost::asio::stream_socket_service<boost::asio::ip::tcp> >, boost::asio::ip::tcp, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > >::do_complete (owner=0x7fffa91a1c30, base=<optimized out>)
    at /usr/include/boost/asio/detail/reactive_socket_accept_op.hpp:123
#17 0x000055555574518d in complete (bytes_transferred=0, ec=..., owner=..., 
    this=<optimized out>)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#18 boost::asio::detail::epoll_reactor::descriptor_state::do_complete (
    owner=0x7fffa91a1c30, base=0x7fffa91b7030, ec=..., 
    bytes_transferred=<optimized out>)
    at /usr/include/boost/asio/detail/impl/epoll_reactor.ipp:651
#19 0x000055555574678e in complete (bytes_transferred=1, ec=..., owner=..., 
    this=0x7fffa91b7030)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#20 do_run_one (ec=..., this_thread=..., lock=..., this=0x7fffa91a1c30)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:384
#21 boost::asio::detail::task_io_service::run (this=0x7fffa91a1c30, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#22 0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf8dda10)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#23 0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#24 0x00007ffff58c9182 in start_thread (arg=0x7fff8b7ae700)
    at pthread_create.c:312
#25 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 22 (Thread 0x7fff8bfff700 (LWP 6124)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x000055555573b1a6 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at sync.h:118
#7  CMutexLock (fTry=false, nLine=852, 
    pszFile=0x555555b4f980 "rpcserver.cpp", pszName=<optimized out>, 
    mutexIn=..., this=<synthetic pointer>) at sync.h:139
#8  CRPCTable::execute (this=this@entry=0x555555ebd9e0 <tableRPC>, 
    strMethod=..., params=...) at rpcserver.cpp:852
#9  0x000055555573dd78 in ServiceConnection (conn=conn@entry=0x7fff9c01e030)
    at rpcserver.cpp:797
#10 0x000055555573eb50 in RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > (acceptor=..., context=..., 
    fUseSSL=<optimized out>, conn=0x7fff9c01e030, error=...)
    at rpcserver.cpp:495
#11 0x000055555574383a in operator()<void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, const boost::system::error_code&), boost::_bi::list1<const boost::system::error_code&> > (
    f=@0x7fff8bffebf0: 0x55555573e940 <RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> >(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&)>, a=<synthetic pointer>, 
    this=0x7fff8bffebf8) at /usr/include/boost/bind/bind.hpp:525
#12 operator()<boost::system::error_code> (a1=..., this=0x7fff8bffebf0)
    at /usr/include/boost/bind/bind_template.hpp:47
#13 operator() (this=0x7fff8bffebf0)
    at /usr/include/boost/asio/detail/bind_handler.hpp:47
#14 asio_handler_invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code> > (
    function=<error reading variable: access outside bounds of object referenced via synthetic pointer>)
    at /usr/include/boost/asio/handler_invoke_hook.hpp:64
#15 invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code>, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > > (context=..., function=...)
    at /usr/include/boost/asio/detail/handler_invoke_helpers.hpp:37
#16 boost::asio::detail::reactive_socket_accept_op<boost::asio::basic_socket<boost::asio::ip::tcp, boost::asio::stream_socket_service<boost::asio::ip::tcp> >, boost::asio::ip::tcp, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > >::do_complete (owner=0x7fffa91a1c30, base=<optimized out>)
    at /usr/include/boost/asio/detail/reactive_socket_accept_op.hpp:123
#17 0x000055555574518d in complete (bytes_transferred=0, ec=..., owner=..., 
    this=<optimized out>)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#18 boost::asio::detail::epoll_reactor::descriptor_state::do_complete (
    owner=0x7fffa91a1c30, base=0x7fffa91b7030, ec=..., 
    bytes_transferred=<optimized out>)
    at /usr/include/boost/asio/detail/impl/epoll_reactor.ipp:651
#19 0x000055555574678e in complete (bytes_transferred=1, ec=..., owner=..., 
    this=0x7fffa91b7030)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#20 do_run_one (ec=..., this_thread=..., lock=..., this=0x7fffa91a1c30)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:384
#21 boost::asio::detail::task_io_service::run (this=0x7fffa91a1c30, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#22 0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf8dda10)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#23 0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#24 0x00007ffff58c9182 in start_thread (arg=0x7fff8bfff700)
    at pthread_create.c:312
#25 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 21 (Thread 0x7fffa0c13700 (LWP 6123)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x000055555573b1a6 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at sync.h:118
#7  CMutexLock (fTry=false, nLine=852, 
    pszFile=0x555555b4f980 "rpcserver.cpp", pszName=<optimized out>, 
    mutexIn=..., this=<synthetic pointer>) at sync.h:139
#8  CRPCTable::execute (this=this@entry=0x555555ebd9e0 <tableRPC>, 
    strMethod=..., params=...) at rpcserver.cpp:852
#9  0x000055555573dd78 in ServiceConnection (conn=conn@entry=0x7fff74000960)
    at rpcserver.cpp:797
#10 0x000055555573eb50 in RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > (acceptor=..., context=..., 
    fUseSSL=<optimized out>, conn=0x7fff74000960, error=...)
    at rpcserver.cpp:495
#11 0x000055555574383a in operator()<void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, const boost::system::error_code&), boost::_bi::list1<const boost::system::error_code&> > (
    f=@0x7fffa0c12bf0: 0x55555573e940 <RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> >(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&)>, a=<synthetic pointer>, 
    this=0x7fffa0c12bf8) at /usr/include/boost/bind/bind.hpp:525
#12 operator()<boost::system::error_code> (a1=..., this=0x7fffa0c12bf0)
    at /usr/include/boost/bind/bind_template.hpp:47
#13 operator() (this=0x7fffa0c12bf0)
    at /usr/include/boost/asio/detail/bind_handler.hpp:47
#14 asio_handler_invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code> > (
    function=<error reading variable: access outside bounds of object referenced via synthetic pointer>)
    at /usr/include/boost/asio/handler_invoke_hook.hpp:64
#15 invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code>, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > > (context=..., function=...)
    at /usr/include/boost/asio/detail/handler_invoke_helpers.hpp:37
#16 boost::asio::detail::reactive_socket_accept_op<boost::asio::basic_socket<boost::asio::ip::tcp, boost::asio::stream_socket_service<boost::asio::ip::tcp> >, boost::asio::ip::tcp, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > >::do_complete (owner=0x7fffa91a1c30, base=<optimized out>)
    at /usr/include/boost/asio/detail/reactive_socket_accept_op.hpp:123
#17 0x000055555574518d in complete (bytes_transferred=0, ec=..., owner=..., 
    this=<optimized out>)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#18 boost::asio::detail::epoll_reactor::descriptor_state::do_complete (
    owner=0x7fffa91a1c30, base=0x7fffa91b7030, ec=..., 
    bytes_transferred=<optimized out>)
    at /usr/include/boost/asio/detail/impl/epoll_reactor.ipp:651
#19 0x000055555574678e in complete (bytes_transferred=1, ec=..., owner=..., 
    this=0x7fffa91b7030)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#20 do_run_one (ec=..., this_thread=..., lock=..., this=0x7fffa91a1c30)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:384
#21 boost::asio::detail::task_io_service::run (this=0x7fffa91a1c30, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#22 0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf8dda10)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#23 0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#24 0x00007ffff58c9182 in start_thread (arg=0x7fffa0c13700)
    at pthread_create.c:312
#25 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 20 (Thread 0x7fffa166a700 (LWP 6122)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x000055555573b1a6 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at sync.h:118
#7  CMutexLock (fTry=false, nLine=852, 
    pszFile=0x555555b4f980 "rpcserver.cpp", pszName=<optimized out>, 
    mutexIn=..., this=<synthetic pointer>) at sync.h:139
#8  CRPCTable::execute (this=this@entry=0x555555ebd9e0 <tableRPC>, 
    strMethod=..., params=...) at rpcserver.cpp:852
#9  0x000055555573dd78 in ServiceConnection (conn=conn@entry=0x7fff700149c0)
    at rpcserver.cpp:797
#10 0x000055555573eb50 in RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > (acceptor=..., context=..., 
    fUseSSL=<optimized out>, conn=0x7fff700149c0, error=...)
    at rpcserver.cpp:495
#11 0x000055555574383a in operator()<void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, const boost::system::error_code&), boost::_bi::list1<const boost::system::error_code&> > (
    f=@0x7fffa1669bf0: 0x55555573e940 <RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> >(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&)>, a=<synthetic pointer>, 
    this=0x7fffa1669bf8) at /usr/include/boost/bind/bind.hpp:525
#12 operator()<boost::system::error_code> (a1=..., this=0x7fffa1669bf0)
    at /usr/include/boost/bind/bind_template.hpp:47
#13 operator() (this=0x7fffa1669bf0)
    at /usr/include/boost/asio/detail/bind_handler.hpp:47
#14 asio_handler_invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code> > (
    function=<error reading variable: access outside bounds of object referenced via synthetic pointer>)
    at /usr/include/boost/asio/handler_invoke_hook.hpp:64
#15 invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code>, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > > (context=..., function=...)
    at /usr/include/boost/asio/detail/handler_invoke_helpers.hpp:37
#16 boost::asio::detail::reactive_socket_accept_op<boost::asio::basic_socket<boost::asio::ip::tcp, boost::asio::stream_socket_service<boost::asio::ip::tcp> >, boost::asio::ip::tcp, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > >::do_complete (owner=0x7fffa91a1c30, base=<optimized out>)
    at /usr/include/boost/asio/detail/reactive_socket_accept_op.hpp:123
#17 0x000055555574518d in complete (bytes_transferred=0, ec=..., owner=..., 
    this=<optimized out>)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#18 boost::asio::detail::epoll_reactor::descriptor_state::do_complete (
    owner=0x7fffa91a1c30, base=0x7fffa91b7030, ec=..., 
    bytes_transferred=<optimized out>)
    at /usr/include/boost/asio/detail/impl/epoll_reactor.ipp:651
#19 0x000055555574678e in complete (bytes_transferred=1, ec=..., owner=..., 
    this=0x7fffa91b7030)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#20 do_run_one (ec=..., this_thread=..., lock=..., this=0x7fffa91a1c30)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:384
#21 boost::asio::detail::task_io_service::run (this=0x7fffa91a1c30, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#22 0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf8dda10)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#23 0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#24 0x00007ffff58c9182 in start_thread (arg=0x7fffa166a700)
    at pthread_create.c:312
#25 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 19 (Thread 0x7fffa1ebb700 (LWP 6121)):
#0  pthread_cond_timedwait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S:238
#1  0x00007ffff754bacc in boost::condition_variable::do_wait_until(boost::unique_lock<boost::mutex>&, timespec const&) ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#2  0x00007ffff75484ba in boost::this_thread::hiden::sleep_for(timespec const&) () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#3  0x0000555555709924 in sleep_for (ns=<synthetic pointer>)
    at /usr/include/boost/thread/pthread/thread_data.hpp:235
#4  boost::this_thread::sleep_for<long, boost::ratio<1l, 1000l> > (d=...)
    at /usr/include/boost/thread/v2/thread.hpp:53
#5  0x000055555571e28d in MilliSleep (n=900000) at util.h:97
#6  LoopForever<void (*)()> (name=0x555555b38008 "dumpaddr", 
    func=0x555555711a70 <DumpAddresses()>, msecs=900000) at util.h:550
#7  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#8  0x00007ffff58c9182 in start_thread (arg=0x7fffa1ebb700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 18 (Thread 0x7fffa270c700 (LWP 6120)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (mutex=0x7fffad215600)
    at ../nptl/pthread_mutex_lock.c:114
#3  0x000055555561c0ad in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at ../../src/sync.h:66
#5  lock (this=0x7fffa270aa60) at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=0x7fffa270aa60) at ../../src/sync.h:118
#7  CMutexLock<AnnotatedMixin<boost::recursive_mutex> >::CMutexLock (
    this=0x7fffa270aa60, mutexIn=..., pszName=<optimized out>, 
    pszFile=<optimized out>, nLine=<optimized out>, fTry=<optimized out>)
    at ../../src/sync.h:139
#8  0x00005555557ce266 in CWallet::SyncTransaction (this=0x7fffad2154b0, 
    hash=..., tx=..., pblock=0x0) at wallet.cpp:609
#9  0x00005555556ff0d5 in operator() (a2=<optimized out>, a1=..., a0=..., 
    this=<optimized out>)
    at /usr/include/boost/function/function_template.hpp:767
#10 m_invoke (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:363
#11 operator() (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:345
#12 dereference (this=0x7fffa270ab60)
    at /usr/include/boost/signals2/detail/slot_call_iterator.hpp:82
#13 dereference<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal3_impl<void, const uint256&, const CTransaction&, const CBlock*, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void(const uint256&, const CTransaction&, const CBlock*)>, boost::function<void(const boost::signals2::connection&, const uint256&, const CTransaction&, const CBlock*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot3<void, const uint256&, const CTransaction&, const CBlock*, boost::function<void(const uint256&, const CTransaction&, const CBlock*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot3<void, const uint256&, const CTransaction&, const CBlock*, boost::function<void(const uint256&, const CTransaction&, const CBlock*)> >, boost::signals2::mutex> > > (f=...)
    at /usr/include/boost/iterator/iterator_facade.hpp:514
#14 operator* (this=0x7fffa270ab60)
    at /usr/include/boost/iterator/iterator_facade.hpp:639
#15 operator()<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal3_impl<void, const uint256&, const CTransaction&, const CBlock*, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void(const uint256&, const CTransaction&, const CBlock*)>, boost::function<void(const boost::signals2::connection&, const uint256&, const CTransaction&, const CBlock*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot3<void, const uint256&, const CTransaction&, const CBlock*, boost::function<void(const uint256&, const CTransaction&, const CBlock*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot3<void, const uint256&, const CTransaction&, const CBlock*, boost::function<void(const uint256&, const CTransaction&, const CBlock*)> >, boost::signals2::mutex> > > (
    this=<optimized out>, first=..., last=...)
    at /usr/include/boost/signals2/optional_last_value.hpp:55
#16 operator()<boost::signals2::optional_last_value<void>, boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal3_impl<void, const uint256&, const CTransaction&, const CBlock*, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void(const uint256&, const CTransaction&, const CBlock*)>, boost::function<void(const boost::signals2::connection&, const uint256&, const CTransaction&, const CBlock*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot3<void, const uint256&, const CTransaction&, const CBlock*, boost::function<void(const uint256&, const CTransaction&, const CBlock*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot3<void, const uint256&, const CTransaction&, const CBlock*, boost::function<void(const uint256&, const CTransaction&, const CBlock*)> >, boost::signals2::mutex> > > (this=<optimized out>, combiner=..., first=..., 
    last=...) at /usr/include/boost/signals2/detail/result_type_wrapper.hpp:64
#17 boost::signals2::detail::signal3_impl<void, uint256 const&, CTransaction const&, CBlock const*, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void (uint256 const&, CTransaction const&, CBlock const*)>, boost::function<void (boost::signals2::connection const&, uint256 const&, CTransaction const&, CBlock const*)>, boost::signals2::mutex>::operator()(uint256 const&, CTransaction const&, CBlock const*) (this=<optimized out>, 
    arg1=..., arg2=..., arg3=arg3@entry=0x0)
    at /usr/include/boost/signals2/detail/signal_template.hpp:246
#18 0x00005555556c63dc in operator() (arg3=0x0, arg2=..., arg1=..., 
    this=0x555555ebce20 <(anonymous namespace)::g_signals>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:695
#19 AcceptToMemoryPool (pool=..., state=..., tx=..., 
    fLimitFree=fLimitFree@entry=true, 
    pfMissingInputs=pfMissingInputs@entry=0x7fffa270b0e5, 
    fRejectInsaneFee=fRejectInsaneFee@entry=false) at main.cpp:955
#20 0x00005555556cdae1 in ProcessMessage (pfrom=pfrom@entry=0x7fff8c002b00, 
    strCommand=..., vRecv=...) at main.cpp:3721
#21 0x00005555556cfde2 in ProcessMessages (pfrom=0x7fff8c002b00)
    at main.cpp:4124
#22 0x000055555572b524 in operator() (a0=<optimized out>, 
    this=<optimized out>)
    at /usr/include/boost/function/function_template.hpp:767
#23 m_invoke (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:368
#24 operator() (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:345
#25 dereference (this=0x7fffa270bb30)
    at /usr/include/boost/signals2/detail/slot_call_iterator.hpp:82
#26 dereference<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool(CNode*)>, boost::function<bool(const boost::signals2::connection&, CNode*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > > (
    f=...) at /usr/include/boost/iterator/iterator_facade.hpp:514
#27 operator* (this=0x7fffa270bb30)
    at /usr/include/boost/iterator/iterator_facade.hpp:639
#28 operator()<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool(CNode*)>, boost::function<bool(const boost::signals2::connection&, CNode*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > > (
    last=..., first=..., this=<optimized out>)
    at /usr/include/boost/signals2/optional_last_value.hpp:34
#29 operator()<boost::signals2::optional_last_value<bool>, boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool(CNode*)>, boost::function<bool(const boost::signals2::connection&, CNode*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > > (this=<optimized out>, last=..., 
    first=..., combiner=...)
    at /usr/include/boost/signals2/detail/result_type_wrapper.hpp:53
#30 boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool (CNode*)>, boost::function<bool (boost::signals2::connection const&, CNode*)>, boost::signals2::mutex>::operator()(CNode*) (this=<optimized out>, 
    arg1=arg1@entry=0x7fff8c002b00)
    at /usr/include/boost/signals2/detail/signal_template.hpp:246
#31 0x0000555555716836 in operator() (arg1=0x7fff8c002b00, 
    this=0x555555ebd738 <g_signals+24>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:695
#32 ThreadMessageHandler () at net.cpp:1544
#33 0x000055555571e373 in TraceThread<void (*)()> (
    name=0x555555b38000 "msghand", 
    func=0x555555716620 <ThreadMessageHandler()>) at util.h:576
#34 0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#35 0x00007ffff58c9182 in start_thread (arg=0x7fffa270c700)
    at pthread_create.c:312
#36 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 17 (Thread 0x7fffa2f5d700 (LWP 6119)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x00005555556b1611 in lock (this=0x555555ebcb80 <cs_main>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=0x555555ebcb80 <cs_main>) at sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at sync.h:118
#7  CMutexLock (fTry=false, nLine=237, pszFile=0x555555b1a81e "main.cpp", 
    pszName=0x555555880e59 "cs_main", mutexIn=..., this=<synthetic pointer>)
    at sync.h:139
#8  (anonymous namespace)::GetHeight () at main.cpp:237
#9  0x0000555555729479 in operator() (this=<optimized out>)
    at /usr/include/boost/function/function_template.hpp:767
#10 m_invoke (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:368
#11 operator() (this=<optimized out>, connectionBody=...)
    at /usr/include/boost/signals2/detail/signal_template.hpp:345
#12 dereference (this=0x7fffa2f5c350)
    at /usr/include/boost/signals2/detail/slot_call_iterator.hpp:82
#13 dereference<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal0_impl<int, boost::signals2::optional_last_value<int>, int, std::less<int>, boost::function<int()>, boost::function<int(const boost::signals2::connection&)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot0<int, boost::function<int()> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot0<int, boost::function<int()> >, boost::signals2::mutex> > > (f=...) at /usr/include/boost/iterator/iterator_facade.hpp:514
#14 operator* (this=0x7fffa2f5c350)
    at /usr/include/boost/iterator/iterator_facade.hpp:639
#15 operator()<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal0_impl<int, boost::signals2::optional_last_value<int>, int, std::less<int>, boost::function<int()>, boost::function<int(const boost::signals2::connection&)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot0<int, boost::function<int()> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot0<int, boost::function<int()> >, boost::signals2::mutex> > > (last=..., first=..., this=<optimized out>)
    at /usr/include/boost/signals2/optional_last_value.hpp:34
#16 operator()<boost::signals2::optional_last_value<int>, boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal0_impl<int, boost::signals2::optional_last_value<int>, int, std::less<int>, boost::function<int()>, boost::function<int(const boost::signals2::connection&)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot0<int, boost::function<int()> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot0<int, boost::function<int()> >, boost::signals2::mutex> > > (
    this=<optimized out>, last=..., first=..., combiner=...)
    at /usr/include/boost/signals2/detail/result_type_wrapper.hpp:53
#17 boost::signals2::detail::signal0_impl<int, boost::signals2::optional_last_value<int>, int, std::less<int>, boost::function<int ()>, boost::function<int (boost::signals2::connection const&)>, boost::signals2::mutex>::operator()() (
    this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:246
#18 0x00005555557122e7 in operator() (this=0x555555ebd720 <g_signals>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:695
#19 CNode::PushVersion (this=this@entry=0x7fff8c004120) at net.cpp:548
#20 0x000055555572a1f2 in CNode::CNode (this=0x7fff8c004120, 
    hSocketIn=<optimized out>, addrIn=..., addrNameIn=..., 
    fInboundIn=<optimized out>) at net.h:312
#21 0x0000555555712c6e in ConnectNode (addrConnect=..., 
    pszDest=pszDest@entry=0x0) at net.cpp:504
#22 0x00005555557131c2 in OpenNetworkConnection (addrConnect=..., 
    grantOutbound=grantOutbound@entry=0x7fffa2f5ccc0, 
    strDest=strDest@entry=0x0, fOneShot=fOneShot@entry=false) at net.cpp:1457
#23 0x0000555555713f34 in ThreadOpenConnections () at net.cpp:1366
#24 0x000055555571e373 in TraceThread<void (*)()> (
    name=0x555555b37ff8 "opencon", 
    func=0x555555713640 <ThreadOpenConnections()>) at util.h:576
#25 0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#26 0x00007ffff58c9182 in start_thread (arg=0x7fffa2f5d700)
    at pthread_create.c:312
#27 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 16 (Thread 0x7fffa37ae700 (LWP 6118)):
#0  pthread_cond_timedwait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S:238
#1  0x00007ffff754bacc in boost::condition_variable::do_wait_until(boost::unique_lock<boost::mutex>&, timespec const&) ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#2  0x00007ffff75484ba in boost::this_thread::hiden::sleep_for(timespec const&) () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#3  0x0000555555709924 in sleep_for (ns=<synthetic pointer>)
    at /usr/include/boost/thread/pthread/thread_data.hpp:235
#4  boost::this_thread::sleep_for<long, boost::ratio<1l, 1000l> > (d=...)
    at /usr/include/boost/thread/v2/thread.hpp:53
#5  0x0000555555714773 in MilliSleep (n=120000) at util.h:97
#6  ThreadOpenAddedConnections () at net.cpp:1438
#7  0x000055555571e373 in TraceThread<void (*)()> (
    name=0x555555b37ff1 "addcon", 
    func=0x555555713f80 <ThreadOpenAddedConnections()>) at util.h:576
#8  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#9  0x00007ffff58c9182 in start_thread (arg=0x7fffa37ae700)
    at pthread_create.c:312
#10 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 15 (Thread 0x7fffa3fff700 (LWP 6117)):
#0  0x00007ffff43d0c33 in select () at ../sysdeps/unix/syscall-template.S:81
#1  0x0000555555715b6e in ThreadSocketHandler () at net.cpp:896
#2  0x000055555571e373 in TraceThread<void (*)()> (name=0x555555b06813 "net", 
    func=0x5555557151e0 <ThreadSocketHandler()>) at util.h:576
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffa3fff700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 11 (Thread 0x7fffc118d700 (LWP 6095)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x00005555556f7033 in wait (m=..., 
    this=0x555555ebcce8 <scriptcheckqueue+40>)
    at /usr/include/boost/thread/pthread/condition_variable.hpp:73
#2  CCheckQueue<CScriptCheck>::Loop (this=0x555555ebccc0 <scriptcheckqueue>, 
    fMaster=false) at checkqueue.h:95
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffc118d700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 10 (Thread 0x7fffc19de700 (LWP 6094)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x00005555556f7033 in wait (m=..., 
    this=0x555555ebcce8 <scriptcheckqueue+40>)
    at /usr/include/boost/thread/pthread/condition_variable.hpp:73
#2  CCheckQueue<CScriptCheck>::Loop (this=0x555555ebccc0 <scriptcheckqueue>, 
    fMaster=false) at checkqueue.h:95
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffc19de700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 9 (Thread 0x7fffc222f700 (LWP 6093)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x00005555556f7033 in wait (m=..., 
    this=0x555555ebcce8 <scriptcheckqueue+40>)
    at /usr/include/boost/thread/pthread/condition_variable.hpp:73
#2  CCheckQueue<CScriptCheck>::Loop (this=0x555555ebccc0 <scriptcheckqueue>, 
    fMaster=false) at checkqueue.h:95
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffc222f700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 8 (Thread 0x7fffe2f61700 (LWP 6087)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff62067be in QEventDispatcherGlib::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#4  0x00007ffff61d80af in QEventLoop::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#5  0x00007ffff61d83a5 in QEventLoop::exec(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#6  0x00007ffff60d4c5f in QThread::exec() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#7  0x00007ffff60d732f in ?? () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#8  0x00007ffff58c9182 in start_thread (arg=0x7fffe2f61700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 7 (Thread 0x7fffe1ebf700 (LWP 6086)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff62067a1 in QEventDispatcherGlib::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#4  0x00007ffff61d80af in QEventLoop::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#5  0x00007ffff61d83a5 in QEventLoop::exec(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#6  0x00007ffff60d4c5f in QThread::exec() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#7  0x00007ffff60d732f in ?? () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#8  0x00007ffff58c9182 in start_thread (arg=0x7fffe1ebf700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 4 (Thread 0x7fffe37b2700 (LWP 6082)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff39c3129 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#4  0x00007ffff39e7f15 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff58c9182 in start_thread (arg=0x7fffe37b2700)
    at pthread_create.c:312
#6  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 3 (Thread 0x7fffe95de700 (LWP 6081)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c330a in g_main_loop_run ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007fffed561e16 in ?? () from /usr/lib/x86_64-linux-gnu/libgio-2.0.so.0
#4  0x00007ffff39e7f15 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff58c9182 in start_thread (arg=0x7fffe95de700)
    at pthread_create.c:312
#6  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 2 (Thread 0x7fffe9e2f700 (LWP 6080)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007fffe9e371ad in ?? ()
   from /usr/lib/x86_64-linux-gnu/gio/modules/libdconfsettings.so
#4  0x00007ffff39e7f15 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff58c9182 in start_thread (arg=0x7fffe9e2f700)
    at pthread_create.c:312
#6  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 1 (Thread 0x7ffff7fc77c0 (LWP 6079)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x0000555555664d54 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at ../../src/sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at ../../src/sync.h:118
#7  CMutexLock (fTry=false, nLine=196, 
    pszFile=0x555555afb29d "transactiontablemodel.cpp", 
    pszName=<optimized out>, mutexIn=..., this=<synthetic pointer>)
    at ../../src/sync.h:139
#8  TransactionTablePriv::index (this=0x5555566c70d0, idx=idx@entry=23040)
    at transactiontablemodel.cpp:196
#9  0x0000555555663a70 in TransactionTableModel::index (this=0x555556859770, 
    row=23040, column=0, parent=...) at transactiontablemodel.cpp:615
#10 0x0000555555660d5d in TransactionFilterProxy::filterAcceptsRow (
    this=0x555557aad020, sourceRow=23040, sourceParent=...)
    at transactionfilterproxy.cpp:33
#11 0x00007ffff6fccfd6 in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#12 0x00007ffff6fcd1cf in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#13 0x00007ffff61ed87a in QMetaObject::activate(QObject*, QMetaObject const*, int, void**) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#14 0x00007ffff6237664 in QAbstractItemModel::rowsInserted(QModelIndex const&, int, int) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#15 0x00007ffff61d35ce in QAbstractItemModel::endInsertRows() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#16 0x00005555556659fc in TransactionTablePriv::updateWallet (
    this=0x5555566c70d0, hash=..., status=status@entry=0)
    at transactiontablemodel.cpp:156
#17 0x000055555566405d in TransactionTableModel::updateTransaction (
    this=0x555556859770, hash=..., status=0) at transactiontablemodel.cpp:255
#18 0x0000555555614566 in WalletModel::updateTransaction (
    this=this@entry=0x55555617d5c0, hash=..., status=<optimized out>)
    at walletmodel.cpp:127
#19 0x000055555562cfdc in WalletModel::qt_static_metacall (_o=0x55555617d5c0, 
    _c=<optimized out>, _id=<optimized out>, _a=0x7fff70017270)
    at moc_walletmodel.cpp:80
#20 0x00007ffff61f1c1e in QObject::event(QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#21 0x00007ffff6a52e2c in QApplicationPrivate::notify_helper(QObject*, QEvent*) () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#22 0x00007ffff6a594a0 in QApplication::notify(QObject*, QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#23 0x00007ffff61d94dd in QCoreApplication::notifyInternal(QObject*, QEvent*)
    () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#24 0x00007ffff61dcb3d in QCoreApplicationPrivate::sendPostedEvents(QObject*, int, QThreadData*) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#25 0x00007ffff6206f83 in ?? () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#26 0x00007ffff39c2e04 in g_main_context_dispatch ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#27 0x00007ffff39c3048 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#28 0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#29 0x00007ffff62067a1 in QEventDispatcherGlib::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#30 0x00007ffff6af4bb6 in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#31 0x00007ffff61d80af in QEventLoop::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#32 0x00007ffff61d83a5 in QEventLoop::exec(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#33 0x00007ffff61ddb79 in QCoreApplication::exec() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#34 0x00005555555b47e9 in main (argc=1, argv=<optimized out>)
    at bitcoin.cpp:580
```
 

comment number: 41202301 
body: I restarted bitcoind, and pretty quickly it hung again.  This seems quite easily reproducible:

```
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 50
ed9fc3069b5db658d8be4a54c9707c228242da9f49aacb96e0299f115e24a993
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 50
f6a9c90d4c613cf0e76d41d012dc8277c8ebf5c6b83309c93d9087975704c946
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 50
5718101a513ba18d902f7a543590edd82dc0e0bd61d7327c2c16bd3a5544c913
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 50
f114730e2470d74a9289d454ae9726976f6fe6f565683ed00cb39e0a1c1a9b26
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 50
838a56f87e9bb3f8690b19268b3d83dd7311cc53858e5c10bb683416ee6cbfc8
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 50
41902e0c90cd155bad447904922fa359b5bf4d01ee32006c853d2121000e0fe0
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 50
67e29ed40704c79392d4d82fa619c78fc0f6aade31d2ee741f961e4597c7cb91
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 50
error: {"code":-4,"message":"Insufficient funds"}
chris@chris:~/.bitcoin$ bc listunspent 0
[too much output]
chris@chris:~/.bitcoin$ bc listunspent 0 | grep amount
        "amount" : 0.01000059,
        "amount" : 0.00090000,
        "amount" : 0.02000000,
        "amount" : 0.11016945,
        "amount" : 0.18438206,
        "amount" : 0.01390000,
        "amount" : 0.00047493,
        "amount" : 0.52000000,
        "amount" : 4.37022011,
        "amount" : 0.01900000,
        "amount" : 0.09990000,
        "amount" : 0.01406309,
        "amount" : 0.00259388,
        "amount" : 0.00016425,
        "amount" : 0.00049679,
        "amount" : 9.90000000,
chris@chris:~/.bitcoin$ bc sendtoaddress 16TBqpEFpivLtDRAtmNnCxEdJW1coodiia 14
[hung]
```

debug.log:

```
2014-04-23 19:03:58 keypool keep 14209
2014-04-23 19:03:58 AddToWallet 41902e0c90cd155bad447904922fa359b5bf4d01ee32006c853d2121000e0fe0  new
2014-04-23 19:03:58 AddToWallet 41902e0c90cd155bad447904922fa359b5bf4d01ee32006c853d2121000e0fe0  
2014-04-23 19:03:58 Relaying wtx 41902e0c90cd155bad447904922fa359b5bf4d01ee32006c853d2121000e0fe0
2014-04-23 19:04:03 keypool reserve 14210
2014-04-23 19:04:03 CommitTransaction:
CTransaction(hash=67e29ed407, ver=1, vin.size=3, vout.size=2, nLockTime=0)
    CTxIn(COutPoint(41902e0c90, 0), scriptSig=3045022100b41b59985e6945)
    CTxIn(COutPoint(5718101a51, 1), scriptSig=3045022100d9bd04c0806130)
    CTxIn(COutPoint(cbf9d5530d, 0), scriptSig=3044022003ddfdb6ae632423)
    CTxOut(nValue=4.37022011, scriptPubKey=OP_DUP OP_HASH160 0cbc367a1158)
    CTxOut(nValue=50.00000000, scriptPubKey=OP_DUP OP_HASH160 3bcc7e7aa19b)
2014-04-23 19:04:03 keypool keep 14210
2014-04-23 19:04:03 AddToWallet 67e29ed40704c79392d4d82fa619c78fc0f6aade31d2ee741f961e4597c7cb91  new
2014-04-23 19:04:03 AddToWallet 67e29ed40704c79392d4d82fa619c78fc0f6aade31d2ee741f961e4597c7cb91  
2014-04-23 19:04:03 Relaying wtx 67e29ed40704c79392d4d82fa619c78fc0f6aade31d2ee741f961e4597c7cb91
```

gdb:

```
  C-c C-c
Program received signal SIGINT, Interrupt.
__lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
135 ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S: No such file or directory.
(gdb) where
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x0000555555664d54 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at ../../src/sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at ../../src/sync.h:118
#7  CMutexLock (fTry=false, nLine=196, 
    pszFile=0x555555afb29d "transactiontablemodel.cpp", 
    pszName=<optimized out>, mutexIn=..., this=<synthetic pointer>)
    at ../../src/sync.h:139
#8  TransactionTablePriv::index (this=0x555556613f20, idx=idx@entry=64625)
    at transactiontablemodel.cpp:196
#9  0x0000555555663a70 in TransactionTableModel::index (this=0x55555685d8f0, 
    row=64625, column=0, parent=...) at transactiontablemodel.cpp:615
#10 0x0000555555660d5d in TransactionFilterProxy::filterAcceptsRow (this=
    0x555557ab0890, sourceRow=64625, sourceParent=...)
    at transactionfilterproxy.cpp:33
#11 0x00007ffff6fccfd6 in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#12 0x00007ffff6fcd1cf in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#13 0x00007ffff61ed87a in QMetaObject::activate(QObject*, QMetaObject const*, int, void**) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#14 0x00007ffff6237664 in QAbstractItemModel::rowsInserted(QModelIndex const&, int, int) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#15 0x00007ffff61d35ce in QAbstractItemModel::endInsertRows() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#16 0x00005555556659fc in TransactionTablePriv::updateWallet (
    this=0x555556613f20, hash=..., status=status@entry=0)
    at transactiontablemodel.cpp:156
#17 0x000055555566405d in TransactionTableModel::updateTransaction (
    this=0x55555685d8f0, hash=..., status=0) at transactiontablemodel.cpp:255
#18 0x0000555555614566 in WalletModel::updateTransaction (
    this=this@entry=0x555556332bd0, hash=..., status=<optimized out>)
    at walletmodel.cpp:127
#19 0x000055555562cfdc in WalletModel::qt_static_metacall (_o=0x555556332bd0, 
    _c=<optimized out>, _id=<optimized out>, _a=0x7fff70017270)
    at moc_walletmodel.cpp:80
#20 0x00007ffff61f1c1e in QObject::event(QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#21 0x00007ffff6a52e2c in QApplicationPrivate::notify_helper(QObject*, QEvent*) () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#22 0x00007ffff6a594a0 in QApplication::notify(QObject*, QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#23 0x00007ffff61d94dd in QCoreApplication::notifyInternal(QObject*, QEvent*)
    () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#24 0x00007ffff61dcb3d in QCoreApplicationPrivate::sendPostedEvents(QObject*, int, QThreadData*) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#25 0x00007ffff6206f83 in ?? () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#26 0x00007ffff39c2e04 in g_main_context_dispatch ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#27 0x00007ffff39c3048 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#28 0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#29 0x00007ffff62067a1 in QEventDispatcherGlib::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#30 0x00007ffff6af4bb6 in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#31 0x00007ffff61d80af in QEventLoop::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#32 0x00007ffff61d83a5 in QEventLoop::exec(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#33 0x00007ffff61ddb79 in QCoreApplication::exec() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#34 0x00005555555b47e9 in main (argc=1, argv=<optimized out>)
    at bitcoin.cpp:580
(gdb) thread apply all where

Thread 25 (Thread 0x7fff7fae6700 (LWP 6268)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x0000555555849bfb in BGThread (this=0x7fffd40e1ee0)
    at util/env_posix.cc:563
#2  leveldb::(anonymous namespace)::PosixEnv::BGThreadWrapper (
    arg=0x7fffd40e1ee0) at util/env_posix.cc:510
#3  0x00007ffff58c9182 in start_thread (arg=0x7fff7fae6700)
    at pthread_create.c:312
#4  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 24 (Thread 0x7fff855e3700 (LWP 6267)):
#0  pthread_cond_timedwait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S:238
#1  0x00007ffff754bacc in boost::condition_variable::do_wait_until(boost::unique_lock<boost::mutex>&, timespec const&) ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#2  0x00007ffff75484ba in boost::this_thread::hiden::sleep_for(timespec const&) () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#3  0x0000555555709924 in sleep_for (ns=<synthetic pointer>)
    at /usr/include/boost/thread/pthread/thread_data.hpp:235
#4  boost::this_thread::sleep_for<long, boost::ratio<1l, 1000l> > (d=...)
    at /usr/include/boost/thread/v2/thread.hpp:53
#5  0x00005555557e19d9 in MilliSleep (n=500) at util.h:97
#6  ThreadFlushWalletDB (strFile=...) at walletdb.cpp:782
#7  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#8  0x00007ffff58c9182 in start_thread (arg=0x7fff855e3700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 23 (Thread 0x7fff87fff700 (LWP 6266)):
#0  0x00007ffff43d99a3 in epoll_wait ()
    at ../sysdeps/unix/syscall-template.S:81
#1  0x000055555574258b in boost::asio::detail::epoll_reactor::run (
    this=0x7fffa91aefe0, block=<optimized out>, ops=...)
    at /usr/include/boost/asio/detail/impl/epoll_reactor.ipp:392
#2  0x0000555555746551 in do_run_one (ec=..., this_thread=..., lock=..., 
    this=0x7fffa91ae190)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:368
#3  boost::asio::detail::task_io_service::run (this=0x7fffa91ae190, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#4  0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf4f74f0)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#5  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#6  0x00007ffff58c9182 in start_thread (arg=0x7fff87fff700)
    at pthread_create.c:312
#7  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 22 (Thread 0x7fffa0a10700 (LWP 6265)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x000055555574671d in wait<boost::asio::detail::scoped_lock<boost::asio::detail::posix_mutex> > (lock=..., this=0x7fffa0a0fdb0)
    at /usr/include/boost/asio/detail/posix_event.hpp:80
#2  do_run_one (ec=..., this_thread=..., lock=..., this=0x7fffa91ae190)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:395
#3  boost::asio::detail::task_io_service::run (this=0x7fffa91ae190, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#4  0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf4f74f0)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#5  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#6  0x00007ffff58c9182 in start_thread (arg=0x7fffa0a10700)
    at pthread_create.c:312
#7  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 21 (Thread 0x7fffa1261700 (LWP 6264)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x000055555574671d in wait<boost::asio::detail::scoped_lock<boost::asio::detail::posix_mutex> > (lock=..., this=0x7fffa1260db0)
    at /usr/include/boost/asio/detail/posix_event.hpp:80
#2  do_run_one (ec=..., this_thread=..., lock=..., this=0x7fffa91ae190)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:395
#3  boost::asio::detail::task_io_service::run (this=0x7fffa91ae190, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#4  0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf4f74f0)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#5  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#6  0x00007ffff58c9182 in start_thread (arg=0x7fffa1261700)
    at pthread_create.c:312
#7  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 20 (Thread 0x7fffa1ab2700 (LWP 6263)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x000055555573b1a6 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at sync.h:118
#7  CMutexLock (fTry=false, nLine=852, 
    pszFile=0x555555b4f980 "rpcserver.cpp", pszName=<optimized out>, 
    mutexIn=..., this=<synthetic pointer>) at sync.h:139
#8  CRPCTable::execute (this=this@entry=0x555555ebd9e0 <tableRPC>, 
    strMethod=..., params=...) at rpcserver.cpp:852
#9  0x000055555573dd78 in ServiceConnection (conn=conn@entry=0x7fff70000cc0)
    at rpcserver.cpp:797
#10 0x000055555573eb50 in RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > (acceptor=..., context=..., 
    fUseSSL=<optimized out>, conn=0x7fff70000cc0, error=...)
    at rpcserver.cpp:495
#11 0x000055555574383a in operator()<void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, const boost::system::error_code&), boost::_bi::list1<const boost::system::error_code&> > (
    f=@0x7fffa1ab1bf0: 0x55555573e940 <RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> >(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&)>, a=<synthetic pointer>, 
    this=0x7fffa1ab1bf8) at /usr/include/boost/bind/bind.hpp:525
#12 operator()<boost::system::error_code> (a1=..., this=0x7fffa1ab1bf0)
    at /usr/include/boost/bind/bind_template.hpp:47
#13 operator() (this=0x7fffa1ab1bf0)
    at /usr/include/boost/asio/detail/bind_handler.hpp:47
#14 asio_handler_invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code> > (
    function=<error reading variable: access outside bounds of object referenced via synthetic pointer>)
    at /usr/include/boost/asio/handler_invoke_hook.hpp:64
#15 invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code>, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > > (context=..., function=...)
    at /usr/include/boost/asio/detail/handler_invoke_helpers.hpp:37
#16 boost::asio::detail::reactive_socket_accept_op<boost::asio::basic_socket<boost::asio::ip::tcp, boost::asio::stream_socket_service<boost::asio::ip::tcp> >, boost::asio::ip::tcp, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > >::do_complete (owner=0x7fffa91ae190, base=<optimized out>)
    at /usr/include/boost/asio/detail/reactive_socket_accept_op.hpp:123
#17 0x000055555574518d in complete (bytes_transferred=0, ec=..., owner=..., 
    this=<optimized out>)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#18 boost::asio::detail::epoll_reactor::descriptor_state::do_complete (
    owner=0x7fffa91ae190, base=0x7fffa91c3590, ec=..., 
    bytes_transferred=<optimized out>)
    at /usr/include/boost/asio/detail/impl/epoll_reactor.ipp:651
#19 0x000055555574678e in complete (bytes_transferred=1, ec=..., owner=..., 
    this=0x7fffa91c3590)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#20 do_run_one (ec=..., this_thread=..., lock=..., this=0x7fffa91ae190)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:384
#21 boost::asio::detail::task_io_service::run (this=0x7fffa91ae190, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#22 0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf4f74f0)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#23 0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#24 0x00007ffff58c9182 in start_thread (arg=0x7fffa1ab2700)
    at pthread_create.c:312
#25 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 19 (Thread 0x7fffa2509700 (LWP 6262)):
#0  pthread_cond_timedwait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S:238
#1  0x00007ffff754bacc in boost::condition_variable::do_wait_until(boost::unique_lock<boost::mutex>&, timespec const&) ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#2  0x00007ffff75484ba in boost::this_thread::hiden::sleep_for(timespec const&) () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#3  0x0000555555709924 in sleep_for (ns=<synthetic pointer>)
    at /usr/include/boost/thread/pthread/thread_data.hpp:235
#4  boost::this_thread::sleep_for<long, boost::ratio<1l, 1000l> > (d=...)
    at /usr/include/boost/thread/v2/thread.hpp:53
#5  0x000055555571e28d in MilliSleep (n=900000) at util.h:97
#6  LoopForever<void (*)()> (name=0x555555b38008 "dumpaddr", 
    func=0x555555711a70 <DumpAddresses()>, msecs=900000) at util.h:550
#7  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#8  0x00007ffff58c9182 in start_thread (arg=0x7fffa2509700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 18 (Thread 0x7fffa2f5d700 (LWP 6261)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (mutex=0x7fffad23e540)
    at ../nptl/pthread_mutex_lock.c:114
#3  0x000055555561c0ad in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at ../../src/sync.h:66
#5  lock (this=0x7fffa2f5bdb0) at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=0x7fffa2f5bdb0) at ../../src/sync.h:118
#7  CMutexLock<AnnotatedMixin<boost::recursive_mutex> >::CMutexLock (
    this=0x7fffa2f5bdb0, mutexIn=..., pszName=<optimized out>, 
    pszFile=<optimized out>, nLine=<optimized out>, fTry=<optimized out>)
    at ../../src/sync.h:139
#8  0x00005555557d295d in CWallet::Inventory (this=0x7fffad23e3f0, hash=...)
    at wallet.h:354
#9  0x00005555557004cc in operator() (a0=..., this=<optimized out>)
    at /usr/include/boost/function/function_template.hpp:767
#10 m_invoke (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:363
#11 operator() (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:345
#12 dereference (this=0x7fffa2f5be80)
    at /usr/include/boost/signals2/detail/slot_call_iterator.hpp:82
#13 dereference<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<void, const uint256&, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void(const uint256&)>, boost::function<void(const boost::signals2::connection&, const uint256&)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > > (f=...)
    at /usr/include/boost/iterator/iterator_facade.hpp:514
#14 operator* (this=0x7fffa2f5be80)
    at /usr/include/boost/iterator/iterator_facade.hpp:639
#15 operator()<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<void, const uint256&, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void(const uint256&)>, boost::function<void(const boost::signals2::connection&, const uint256&)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > > (this=<optimized out>, 
    first=..., last=...)
    at /usr/include/boost/signals2/optional_last_value.hpp:55
#16 operator()<boost::signals2::optional_last_value<void>, boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<void, const uint256&, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void(const uint256&)>, boost::function<void(const boost::signals2::connection&, const uint256&)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > > (this=<optimized out>, combiner=..., first=..., last=...)
    at /usr/include/boost/signals2/detail/result_type_wrapper.hpp:64
#17 boost::signals2::detail::signal1_impl<void, uint256 const&, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void (uint256 const&)>, boost::function<void (boost::signals2::connection const&, uint256 const&)>, boost::signals2::mutex>::operator()(uint256 const&) (
    this=<optimized out>, arg1=...)
    at /usr/include/boost/signals2/detail/signal_template.hpp:246
#18 0x00005555556cca02 in operator() (arg1=..., 
    this=0x555555ebce80 <(anonymous namespace)::g_signals+96>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:695
#19 ProcessMessage (pfrom=pfrom@entry=0x7fff940046c0, strCommand=..., 
    vRecv=...) at main.cpp:3606
#20 0x00005555556cfde2 in ProcessMessages (pfrom=0x7fff940046c0)
    at main.cpp:4124
#21 0x000055555572b524 in operator() (a0=<optimized out>, 
    this=<optimized out>)
    at /usr/include/boost/function/function_template.hpp:767
#22 m_invoke (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:368
#23 operator() (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:345
#24 dereference (this=0x7fffa2f5cb30)
    at /usr/include/boost/signals2/detail/slot_call_iterator.hpp:82
#25 dereference<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool(CNode*)>, boost::function<bool(const boost::signals2::connection&, CNode*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > > (
    f=...) at /usr/include/boost/iterator/iterator_facade.hpp:514
#26 operator* (this=0x7fffa2f5cb30)
    at /usr/include/boost/iterator/iterator_facade.hpp:639
#27 operator()<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool(CNode*)>, boost::function<bool(const boost::signals2::connection&, CNode*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > > (
    last=..., first=..., this=<optimized out>)
    at /usr/include/boost/signals2/optional_last_value.hpp:34
#28 operator()<boost::signals2::optional_last_value<bool>, boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool(CNode*)>, boost::function<bool(const boost::signals2::connection&, CNode*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > > (this=<optimized out>, last=..., 
    first=..., combiner=...)
    at /usr/include/boost/signals2/detail/result_type_wrapper.hpp:53
#29 boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool (CNode*)>, boost::function<bool (boost::signals2::connection const&, CNode*)>, boost::signals2::mutex>::operator()(CNode*) (this=<optimized out>, 
    arg1=arg1@entry=0x7fff940046c0)
    at /usr/include/boost/signals2/detail/signal_template.hpp:246
#30 0x0000555555716836 in operator() (arg1=0x7fff940046c0, 
    this=0x555555ebd738 <g_signals+24>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:695
#31 ThreadMessageHandler () at net.cpp:1544
#32 0x000055555571e373 in TraceThread<void (*)()> (
    name=0x555555b38000 "msghand", 
    func=0x555555716620 <ThreadMessageHandler()>) at util.h:576
#33 0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#34 0x00007ffff58c9182 in start_thread (arg=0x7fffa2f5d700)
    at pthread_create.c:312
#35 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 17 (Thread 0x7fffa37ae700 (LWP 6260)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x0000555555709c43 in boost::condition_variable::wait (
    this=0x7fffa91ab810, m=...)
    at /usr/include/boost/thread/pthread/condition_variable.hpp:73
#2  0x000055555571390b in wait (this=0x7fffa91ab810) at sync.h:185
#3  Acquire (this=0x7fffa37adcc0) at sync.h:218
#4  CSemaphoreGrant (fTry=false, sema=..., this=0x7fffa37adcc0) at sync.h:249
#5  ThreadOpenConnections () at net.cpp:1299
#6  0x000055555571e373 in TraceThread<void (*)()> (
    name=0x555555b37ff8 "opencon", 
    func=0x555555713640 <ThreadOpenConnections()>) at util.h:576
#7  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#8  0x00007ffff58c9182 in start_thread (arg=0x7fffa37ae700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 16 (Thread 0x7fffa3fff700 (LWP 6259)):
#0  pthread_cond_timedwait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S:238
#1  0x00007ffff754bacc in boost::condition_variable::do_wait_until(boost::unique_lock<boost::mutex>&, timespec const&) ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#2  0x00007ffff75484ba in boost::this_thread::hiden::sleep_for(timespec const&) () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#3  0x0000555555709924 in sleep_for (ns=<synthetic pointer>)
    at /usr/include/boost/thread/pthread/thread_data.hpp:235
#4  boost::this_thread::sleep_for<long, boost::ratio<1l, 1000l> > (d=...)
    at /usr/include/boost/thread/v2/thread.hpp:53
#5  0x0000555555714773 in MilliSleep (n=120000) at util.h:97
#6  ThreadOpenAddedConnections () at net.cpp:1438
#7  0x000055555571e373 in TraceThread<void (*)()> (
    name=0x555555b37ff1 "addcon", 
    func=0x555555713f80 <ThreadOpenAddedConnections()>) at util.h:576
#8  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#9  0x00007ffff58c9182 in start_thread (arg=0x7fffa3fff700)
    at pthread_create.c:312
#10 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 15 (Thread 0x7fffb09c8700 (LWP 6258)):
#0  0x00007ffff43d0c33 in select () at ../sysdeps/unix/syscall-template.S:81
#1  0x0000555555715b6e in ThreadSocketHandler () at net.cpp:896
#2  0x000055555571e373 in TraceThread<void (*)()> (name=0x555555b06813 "net", 
    func=0x5555557151e0 <ThreadSocketHandler()>) at util.h:576
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffb09c8700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 11 (Thread 0x7fffc118d700 (LWP 6234)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x00005555556f7033 in wait (m=..., 
    this=0x555555ebcce8 <scriptcheckqueue+40>)
    at /usr/include/boost/thread/pthread/condition_variable.hpp:73
#2  CCheckQueue<CScriptCheck>::Loop (this=0x555555ebccc0 <scriptcheckqueue>, 
    fMaster=false) at checkqueue.h:95
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffc118d700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 10 (Thread 0x7fffc19de700 (LWP 6233)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x00005555556f7033 in wait (m=..., 
    this=0x555555ebcce8 <scriptcheckqueue+40>)
    at /usr/include/boost/thread/pthread/condition_variable.hpp:73
#2  CCheckQueue<CScriptCheck>::Loop (this=0x555555ebccc0 <scriptcheckqueue>, 
    fMaster=false) at checkqueue.h:95
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffc19de700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 9 (Thread 0x7fffc222f700 (LWP 6232)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x00005555556f7033 in wait (m=..., 
    this=0x555555ebcce8 <scriptcheckqueue+40>)
    at /usr/include/boost/thread/pthread/condition_variable.hpp:73
#2  CCheckQueue<CScriptCheck>::Loop (this=0x555555ebccc0 <scriptcheckqueue>, 
    fMaster=false) at checkqueue.h:95
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffc222f700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 8 (Thread 0x7fffe2710700 (LWP 6230)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff62067be in QEventDispatcherGlib::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#4  0x00007ffff61d80af in QEventLoop::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#5  0x00007ffff61d83a5 in QEventLoop::exec(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#6  0x00007ffff60d4c5f in QThread::exec() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#7  0x00007ffff60d732f in ?? () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#8  0x00007ffff58c9182 in start_thread (arg=0x7fffe2710700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 7 (Thread 0x7fffe1ebf700 (LWP 6229)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff62067a1 in QEventDispatcherGlib::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#4  0x00007ffff61d80af in QEventLoop::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#5  0x00007ffff61d83a5 in QEventLoop::exec(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#6  0x00007ffff60d4c5f in QThread::exec() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#7  0x00007ffff60d732f in ?? () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#8  0x00007ffff58c9182 in start_thread (arg=0x7fffe1ebf700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 4 (Thread 0x7fffe37b2700 (LWP 6225)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff39c3129 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#4  0x00007ffff39e7f15 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff58c9182 in start_thread (arg=0x7fffe37b2700)
    at pthread_create.c:312
#6  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 3 (Thread 0x7fffe95de700 (LWP 6224)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c330a in g_main_loop_run ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007fffed561e16 in ?? () from /usr/lib/x86_64-linux-gnu/libgio-2.0.so.0
#4  0x00007ffff39e7f15 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff58c9182 in start_thread (arg=0x7fffe95de700)
    at pthread_create.c:312
#6  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 2 (Thread 0x7fffe9e2f700 (LWP 6223)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007fffe9e371ad in ?? ()
   from /usr/lib/x86_64-linux-gnu/gio/modules/libdconfsettings.so
#4  0x00007ffff39e7f15 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff58c9182 in start_thread (arg=0x7fffe9e2f700)
    at pthread_create.c:312
#6  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 1 (Thread 0x7ffff7fc77c0 (LWP 6219)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x0000555555664d54 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at ../../src/sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at ../../src/sync.h:118
#7  CMutexLock (fTry=false, nLine=196, 
    pszFile=0x555555afb29d "transactiontablemodel.cpp", 
    pszName=<optimized out>, mutexIn=..., this=<synthetic pointer>)
    at ../../src/sync.h:139
#8  TransactionTablePriv::index (this=0x555556613f20, idx=idx@entry=64625)
    at transactiontablemodel.cpp:196
#9  0x0000555555663a70 in TransactionTableModel::index (this=0x55555685d8f0, 
    row=64625, column=0, parent=...) at transactiontablemodel.cpp:615
#10 0x0000555555660d5d in TransactionFilterProxy::filterAcceptsRow (
    this=0x555557ab0890, sourceRow=64625, sourceParent=...)
    at transactionfilterproxy.cpp:33
#11 0x00007ffff6fccfd6 in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#12 0x00007ffff6fcd1cf in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#13 0x00007ffff61ed87a in QMetaObject::activate(QObject*, QMetaObject const*, int, void**) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#14 0x00007ffff6237664 in QAbstractItemModel::rowsInserted(QModelIndex const&, int, int) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#15 0x00007ffff61d35ce in QAbstractItemModel::endInsertRows() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#16 0x00005555556659fc in TransactionTablePriv::updateWallet (
    this=0x555556613f20, hash=..., status=status@entry=0)
    at transactiontablemodel.cpp:156
#17 0x000055555566405d in TransactionTableModel::updateTransaction (
    this=0x55555685d8f0, hash=..., status=0) at transactiontablemodel.cpp:255
#18 0x0000555555614566 in WalletModel::updateTransaction (
    this=this@entry=0x555556332bd0, hash=..., status=<optimized out>)
    at walletmodel.cpp:127
#19 0x000055555562cfdc in WalletModel::qt_static_metacall (_o=0x555556332bd0, 
    _c=<optimized out>, _id=<optimized out>, _a=0x7fff70017270)
    at moc_walletmodel.cpp:80
#20 0x00007ffff61f1c1e in QObject::event(QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#21 0x00007ffff6a52e2c in QApplicationPrivate::notify_helper(QObject*, QEvent*) () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#22 0x00007ffff6a594a0 in QApplication::notify(QObject*, QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#23 0x00007ffff61d94dd in QCoreApplication::notifyInternal(QObject*, QEvent*)
    () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#24 0x00007ffff61dcb3d in QCoreApplicationPrivate::sendPostedEvents(QObject*, int, QThreadData*) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#25 0x00007ffff6206f83 in ?? () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#26 0x00007ffff39c2e04 in g_main_context_dispatch ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#27 0x00007ffff39c3048 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#28 0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#29 0x00007ffff62067a1 in QEventDispatcherGlib::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#30 0x00007ffff6af4bb6 in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#31 0x00007ffff61d80af in QEventLoop::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#32 0x00007ffff61d83a5 in QEventLoop::exec(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#33 0x00007ffff61ddb79 in QCoreApplication::exec() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#34 0x00005555555b47e9 in main (argc=1, argv=<optimized out>)
    at bitcoin.cpp:580
(gdb) 
```
 

comment number: 41203784 
body: Can you compile with -DDEBUG_LOCKORDER? If it is a lock ordering issue it should come to light then.
 

comment number: 41203974 
body: Sure.  Is it better to build from the trunk, or from the version I'm already using?

I don't know if you've made other related changes in the last 8 days.
 

comment number: 41205125 
body: Well I merged #4085 today, which fixes a hanging GUI in some cases, but I'm not sure it would affect this. 

Edit: May be better not to upgrade to make sure that this problem can still be reproduced.
 

comment number: 41206400 
body: Looking at the traceback of the GUI thread there is, in both cases:

```
#8  TransactionTablePriv::index (this=0x555556613f20, idx=idx@entry=64625)
    at transactiontablemodel.cpp:196
....
#16 0x00005555556659fc in TransactionTablePriv::updateWallet (
    this=0x555556613f20, hash=..., status=status@entry=0)
    at transactiontablemodel.cpp:156
```

TransactionTablePriv::updateWallet acquires both the `cs_main` and `cs_wallet` lock using `LOCK2`. Then, with the locks held, it calls `endInsertRows()` which eventually deeper in the code ends up in `TransactionTablePriv::index()`.

This function, in turn, also does a `LOCK2(cs_main, cs_wallet)`. But weirdly enough, here it hangs. With recursive mutexes re-acquiring a lock should never hang should it? It already has both of these locks.
 

comment number: 41207626 
body: I don't know.

It sounds like a workaround for this would be to just use bitcoind instead of bitcoin-qt, since I'm only using the RPC interface anyway and always keep the QT window minimised.

Also, how do I add the -D compiler flag in the autotools build system?
 

comment number: 41207816 
body: Like this:

```
./configure CPPFLAGS="-DDEBUG_LOCKORDER"
```
 

comment number: 41208538 
body: I'm rebuilding with the debug flag, but in the mean time it hung up again, and this time I hadn't been making any transactions at all:

```
  C-c C-c
Program received signal SIGINT, Interrupt.
__lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
135 ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S: No such file or directory.
(gdb) where
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x0000555555664d54 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at ../../src/sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at ../../src/sync.h:118
#7  CMutexLock (fTry=false, nLine=196, 
    pszFile=0x555555afb29d "transactiontablemodel.cpp", 
    pszName=<optimized out>, mutexIn=..., this=<synthetic pointer>)
    at ../../src/sync.h:139
#8  TransactionTablePriv::index (this=0x555556729f20, idx=idx@entry=40217)
    at transactiontablemodel.cpp:196
#9  0x0000555555663a70 in TransactionTableModel::index (this=0x555556852420, 
    row=40217, column=0, parent=...) at transactiontablemodel.cpp:615
#10 0x0000555555660d5d in TransactionFilterProxy::filterAcceptsRow (
    this=0x555557aa5960, sourceRow=40217, sourceParent=...)
    at transactionfilterproxy.cpp:33
#11 0x00007ffff6fccfd6 in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#12 0x00007ffff6fcd1cf in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#13 0x00007ffff61ed87a in QMetaObject::activate(QObject*, QMetaObject const*, int, void**) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#14 0x00007ffff6237664 in QAbstractItemModel::rowsInserted(QModelIndex const&, int, int) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#15 0x00007ffff61d35ce in QAbstractItemModel::endInsertRows() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#16 0x00005555556659fc in TransactionTablePriv::updateWallet (
    this=0x555556729f20, hash=..., status=status@entry=0)
    at transactiontablemodel.cpp:156
#17 0x000055555566405d in TransactionTableModel::updateTransaction (
    this=0x555556852420, hash=..., status=0) at transactiontablemodel.cpp:255
#18 0x0000555555614566 in WalletModel::updateTransaction (
    this=this@entry=0x555556226790, hash=..., status=<optimized out>)
    at walletmodel.cpp:127
#19 0x000055555562cfdc in WalletModel::qt_static_metacall (_o=0x555556226790, 
    _c=<optimized out>, _id=<optimized out>, _a=0x7fff9158d220)
    at moc_walletmodel.cpp:80
#20 0x00007ffff61f1c1e in QObject::event(QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#21 0x00007ffff6a52e2c in QApplicationPrivate::notify_helper(QObject*, QEvent*) () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#22 0x00007ffff6a594a0 in QApplication::notify(QObject*, QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#23 0x00007ffff61d94dd in QCoreApplication::notifyInternal(QObject*, QEvent*)
    () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#24 0x00007ffff61dcb3d in QCoreApplicationPrivate::sendPostedEvents(QObject*, int, QThreadData*) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#25 0x00007ffff6206f83 in ?? () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#26 0x00007ffff39c2e04 in g_main_context_dispatch ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#27 0x00007ffff39c3048 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#28 0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#29 0x00007ffff62067a1 in QEventDispatcherGlib::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#30 0x00007ffff6af4bb6 in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#31 0x00007ffff61d80af in QEventLoop::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#32 0x00007ffff61d83a5 in QEventLoop::exec(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#33 0x00007ffff61ddb79 in QCoreApplication::exec() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#34 0x00005555555b47e9 in main (argc=1, argv=<optimized out>)
    at bitcoin.cpp:580
(gdb) thread apply all where

Thread 25 (Thread 0x7fff7d9ce700 (LWP 6502)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x0000555555849bfb in BGThread (this=0x7fffc81fa820)
    at util/env_posix.cc:563
#2  leveldb::(anonymous namespace)::PosixEnv::BGThreadWrapper (
    arg=0x7fffc81fa820) at util/env_posix.cc:510
#3  0x00007ffff58c9182 in start_thread (arg=0x7fff7d9ce700)
    at pthread_create.c:312
#4  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 24 (Thread 0x7fff890c8700 (LWP 6501)):
#0  pthread_cond_timedwait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S:238
#1  0x00007ffff754bacc in boost::condition_variable::do_wait_until(boost::unique_lock<boost::mutex>&, timespec const&) ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#2  0x00007ffff75484ba in boost::this_thread::hiden::sleep_for(timespec const&) () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#3  0x0000555555709924 in sleep_for (ns=<synthetic pointer>)
    at /usr/include/boost/thread/pthread/thread_data.hpp:235
#4  boost::this_thread::sleep_for<long, boost::ratio<1l, 1000l> > (d=...)
    at /usr/include/boost/thread/v2/thread.hpp:53
#5  0x00005555557e19d9 in MilliSleep (n=500) at util.h:97
#6  ThreadFlushWalletDB (strFile=...) at walletdb.cpp:782
#7  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#8  0x00007ffff58c9182 in start_thread (arg=0x7fff890c8700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 23 (Thread 0x7fff8b7ae700 (LWP 6500)):
#0  0x00007ffff43d99a3 in epoll_wait ()
    at ../sysdeps/unix/syscall-template.S:81
#1  0x000055555574258b in boost::asio::detail::epoll_reactor::run (
    this=0x7fffa8f6df70, block=<optimized out>, ops=...)
    at /usr/include/boost/asio/detail/impl/epoll_reactor.ipp:392
#2  0x0000555555746551 in do_run_one (ec=..., this_thread=..., lock=..., 
    this=0x7fffa8f6d120)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:368
#3  boost::asio::detail::task_io_service::run (this=0x7fffa8f6d120, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#4  0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf269300)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#5  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#6  0x00007ffff58c9182 in start_thread (arg=0x7fff8b7ae700)
    at pthread_create.c:312
#7  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 22 (Thread 0x7fff8bfff700 (LWP 6499)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x000055555574671d in wait<boost::asio::detail::scoped_lock<boost::asio::detail::posix_mutex> > (lock=..., this=0x7fff8bffedb0)
    at /usr/include/boost/asio/detail/posix_event.hpp:80
#2  do_run_one (ec=..., this_thread=..., lock=..., this=0x7fffa8f6d120)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:395
#3  boost::asio::detail::task_io_service::run (this=0x7fffa8f6d120, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#4  0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf269300)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#5  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#6  0x00007ffff58c9182 in start_thread (arg=0x7fff8bfff700)
    at pthread_create.c:312
#7  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 21 (Thread 0x7fffa0e19700 (LWP 6498)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x000055555574671d in wait<boost::asio::detail::scoped_lock<boost::asio::detail::posix_mutex> > (lock=..., this=0x7fffa0e18db0)
    at /usr/include/boost/asio/detail/posix_event.hpp:80
#2  do_run_one (ec=..., this_thread=..., lock=..., this=0x7fffa8f6d120)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:395
#3  boost::asio::detail::task_io_service::run (this=0x7fffa8f6d120, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#4  0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf269300)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#5  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#6  0x00007ffff58c9182 in start_thread (arg=0x7fffa0e19700)
    at pthread_create.c:312
#7  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 20 (Thread 0x7fffa166a700 (LWP 6497)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x000055555573b1a6 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at sync.h:118
#7  CMutexLock (fTry=false, nLine=852, 
    pszFile=0x555555b4f980 "rpcserver.cpp", pszName=<optimized out>, 
    mutexIn=..., this=<synthetic pointer>) at sync.h:139
#8  CRPCTable::execute (this=this@entry=0x555555ebd9e0 <tableRPC>, 
    strMethod=..., params=...) at rpcserver.cpp:852
#9  0x000055555573dd78 in ServiceConnection (conn=conn@entry=0x7fff700148b0)
    at rpcserver.cpp:797
#10 0x000055555573eb50 in RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > (acceptor=..., context=..., 
    fUseSSL=<optimized out>, conn=0x7fff700148b0, error=...)
    at rpcserver.cpp:495
#11 0x000055555574383a in operator()<void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, const boost::system::error_code&), boost::_bi::list1<const boost::system::error_code&> > (
    f=@0x7fffa1669bf0: 0x55555573e940 <RPCAcceptHandler<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> >(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&)>, a=<synthetic pointer>, 
    this=0x7fffa1669bf8) at /usr/include/boost/bind/bind.hpp:525
#12 operator()<boost::system::error_code> (a1=..., this=0x7fffa1669bf0)
    at /usr/include/boost/bind/bind_template.hpp:47
#13 operator() (this=0x7fffa1669bf0)
    at /usr/include/boost/asio/detail/bind_handler.hpp:47
#14 asio_handler_invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code> > (
    function=<error reading variable: access outside bounds of object referenced via synthetic pointer>)
    at /usr/include/boost/asio/handler_invoke_hook.hpp:64
#15 invoke<boost::asio::detail::binder1<boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> >, boost::system::error_code>, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp> > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > > (context=..., function=...)
    at /usr/include/boost/asio/detail/handler_invoke_helpers.hpp:37
#16 boost::asio::detail::reactive_socket_accept_op<boost::asio::basic_socket<boost::asio::ip::tcp, boost::asio::stream_socket_service<boost::asio::ip::tcp> >, boost::asio::ip::tcp, boost::_bi::bind_t<void, void (*)(boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > >, boost::asio::ssl::context&, bool, AcceptedConnection*, boost::system::error_code const&), boost::_bi::list5<boost::_bi::value<boost::shared_ptr<boost::asio::basic_socket_acceptor<boost::asio::ip::tcp, boost::asio::socket_acceptor_service<boost::asio::ip::tcp> > > >, boost::reference_wrapper<boost::asio::ssl::context>, boost::_bi::value<bool>, boost::_bi::value<AcceptedConnectionImpl<boost::asio::ip::tcp>*>, boost::arg<1> (*)()> > >::do_complete (owner=0x7fffa8f6d120, base=<optimized out>)
    at /usr/include/boost/asio/detail/reactive_socket_accept_op.hpp:123
#17 0x000055555574518d in complete (bytes_transferred=0, ec=..., owner=..., 
    this=<optimized out>)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#18 boost::asio::detail::epoll_reactor::descriptor_state::do_complete (
    owner=0x7fffa8f6d120, base=0x7fffa8f82520, ec=..., 
    bytes_transferred=<optimized out>)
    at /usr/include/boost/asio/detail/impl/epoll_reactor.ipp:651
#19 0x000055555574678e in complete (bytes_transferred=1, ec=..., owner=..., 
    this=0x7fffa8f82520)
    at /usr/include/boost/asio/detail/task_io_service_operation.hpp:37
#20 do_run_one (ec=..., this_thread=..., lock=..., this=0x7fffa8f6d120)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:384
#21 boost::asio::detail::task_io_service::run (this=0x7fffa8f6d120, ec=...)
    at /usr/include/boost/asio/detail/impl/task_io_service.ipp:153
#22 0x0000555555747006 in boost::asio::io_service::run (this=0x7fffaf269300)
    at /usr/include/boost/asio/impl/io_service.ipp:59
#23 0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#24 0x00007ffff58c9182 in start_thread (arg=0x7fffa166a700)
    at pthread_create.c:312
#25 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 19 (Thread 0x7fffa1ebb700 (LWP 6496)):
#0  pthread_cond_timedwait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S:238
#1  0x00007ffff754bacc in boost::condition_variable::do_wait_until(boost::unique_lock<boost::mutex>&, timespec const&) ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#2  0x00007ffff75484ba in boost::this_thread::hiden::sleep_for(timespec const&) () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#3  0x0000555555709924 in sleep_for (ns=<synthetic pointer>)
    at /usr/include/boost/thread/pthread/thread_data.hpp:235
#4  boost::this_thread::sleep_for<long, boost::ratio<1l, 1000l> > (d=...)
    at /usr/include/boost/thread/v2/thread.hpp:53
#5  0x000055555571e28d in MilliSleep (n=900000) at util.h:97
#6  LoopForever<void (*)()> (name=0x555555b38008 "dumpaddr", 
    func=0x555555711a70 <DumpAddresses()>, msecs=900000) at util.h:550
#7  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#8  0x00007ffff58c9182 in start_thread (arg=0x7fffa1ebb700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 18 (Thread 0x7fffa270c700 (LWP 6495)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (mutex=0x7fffad00b000)
    at ../nptl/pthread_mutex_lock.c:114
#3  0x000055555561c0ad in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at ../../src/sync.h:66
#5  lock (this=0x7fffa270adb0) at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=0x7fffa270adb0) at ../../src/sync.h:118
#7  CMutexLock<AnnotatedMixin<boost::recursive_mutex> >::CMutexLock (
    this=0x7fffa270adb0, mutexIn=..., pszName=<optimized out>, 
    pszFile=<optimized out>, nLine=<optimized out>, fTry=<optimized out>)
    at ../../src/sync.h:139
#8  0x00005555557d295d in CWallet::Inventory (this=0x7fffad00aeb0, hash=...)
    at wallet.h:354
#9  0x00005555557004cc in operator() (a0=..., this=<optimized out>)
    at /usr/include/boost/function/function_template.hpp:767
#10 m_invoke (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:363
#11 operator() (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:345
#12 dereference (this=0x7fffa270ae80)
    at /usr/include/boost/signals2/detail/slot_call_iterator.hpp:82
#13 dereference<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<void, const uint256&, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void(const uint256&)>, boost::function<void(const boost::signals2::connection&, const uint256&)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > > (f=...)
    at /usr/include/boost/iterator/iterator_facade.hpp:514
#14 operator* (this=0x7fffa270ae80)
    at /usr/include/boost/iterator/iterator_facade.hpp:639
#15 operator()<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<void, const uint256&, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void(const uint256&)>, boost::function<void(const boost::signals2::connection&, const uint256&)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > > (this=<optimized out>, 
    first=..., last=...)
    at /usr/include/boost/signals2/optional_last_value.hpp:55
#16 operator()<boost::signals2::optional_last_value<void>, boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<void, const uint256&, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void(const uint256&)>, boost::function<void(const boost::signals2::connection&, const uint256&)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<void, const uint256&, boost::function<void(const uint256&)> >, boost::signals2::mutex> > > (this=<optimized out>, combiner=..., first=..., last=...)
    at /usr/include/boost/signals2/detail/result_type_wrapper.hpp:64
#17 boost::signals2::detail::signal1_impl<void, uint256 const&, boost::signals2::optional_last_value<void>, int, std::less<int>, boost::function<void (uint256 const&)>, boost::function<void (boost::signals2::connection const&, uint256 const&)>, boost::signals2::mutex>::operator()(uint256 const&) (
    this=<optimized out>, arg1=...)
    at /usr/include/boost/signals2/detail/signal_template.hpp:246
#18 0x00005555556cca02 in operator() (arg1=..., 
    this=0x555555ebce80 <(anonymous namespace)::g_signals+96>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:695
#19 ProcessMessage (pfrom=pfrom@entry=0x7fff8c004dd0, strCommand=..., 
    vRecv=...) at main.cpp:3606
#20 0x00005555556cfde2 in ProcessMessages (pfrom=0x7fff8c004dd0)
    at main.cpp:4124
#21 0x000055555572b524 in operator() (a0=<optimized out>, 
    this=<optimized out>)
    at /usr/include/boost/function/function_template.hpp:767
#22 m_invoke (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:368
#23 operator() (connectionBody=..., this=<optimized out>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:345
#24 dereference (this=0x7fffa270bb30)
    at /usr/include/boost/signals2/detail/slot_call_iterator.hpp:82
#25 dereference<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool(CNode*)>, boost::function<bool(const boost::signals2::connection&, CNode*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > > (
    f=...) at /usr/include/boost/iterator/iterator_facade.hpp:514
#26 operator* (this=0x7fffa270bb30)
    at /usr/include/boost/iterator/iterator_facade.hpp:639
#27 operator()<boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool(CNode*)>, boost::function<bool(const boost::signals2::connection&, CNode*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > > (
    last=..., first=..., this=<optimized out>)
    at /usr/include/boost/signals2/optional_last_value.hpp:34
#28 operator()<boost::signals2::optional_last_value<bool>, boost::signals2::detail::slot_call_iterator_t<boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool(CNode*)>, boost::function<bool(const boost::signals2::connection&, CNode*)>, boost::signals2::mutex>::slot_invoker, std::_List_iterator<boost::shared_ptr<boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > >, boost::signals2::detail::connection_body<std::pair<boost::signals2::detail::slot_meta_group, boost::optional<int> >, boost::signals2::slot1<bool, CNode*, boost::function<bool(CNode*)> >, boost::signals2::mutex> > > (this=<optimized out>, last=..., 
    first=..., combiner=...)
    at /usr/include/boost/signals2/detail/result_type_wrapper.hpp:53
#29 boost::signals2::detail::signal1_impl<bool, CNode*, boost::signals2::optional_last_value<bool>, int, std::less<int>, boost::function<bool (CNode*)>, boost::function<bool (boost::signals2::connection const&, CNode*)>, boost::signals2::mutex>::operator()(CNode*) (this=<optimized out>, 
    arg1=arg1@entry=0x7fff8c004dd0)
    at /usr/include/boost/signals2/detail/signal_template.hpp:246
#30 0x0000555555716836 in operator() (arg1=0x7fff8c004dd0, 
    this=0x555555ebd738 <g_signals+24>)
    at /usr/include/boost/signals2/detail/signal_template.hpp:695
#31 ThreadMessageHandler () at net.cpp:1544
#32 0x000055555571e373 in TraceThread<void (*)()> (
    name=0x555555b38000 "msghand", 
    func=0x555555716620 <ThreadMessageHandler()>) at util.h:576
#33 0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#34 0x00007ffff58c9182 in start_thread (arg=0x7fffa270c700)
    at pthread_create.c:312
#35 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 17 (Thread 0x7fffa2f5d700 (LWP 6494)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x0000555555709c43 in boost::condition_variable::wait (
    this=0x7fffa8f6a7a0, m=...)
    at /usr/include/boost/thread/pthread/condition_variable.hpp:73
#2  0x000055555571390b in wait (this=0x7fffa8f6a7a0) at sync.h:185
#3  Acquire (this=0x7fffa2f5ccc0) at sync.h:218
#4  CSemaphoreGrant (fTry=false, sema=..., this=0x7fffa2f5ccc0) at sync.h:249
#5  ThreadOpenConnections () at net.cpp:1299
#6  0x000055555571e373 in TraceThread<void (*)()> (
    name=0x555555b37ff8 "opencon", 
    func=0x555555713640 <ThreadOpenConnections()>) at util.h:576
#7  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#8  0x00007ffff58c9182 in start_thread (arg=0x7fffa2f5d700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 16 (Thread 0x7fffa37ae700 (LWP 6493)):
#0  pthread_cond_timedwait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S:238
#1  0x00007ffff754bacc in boost::condition_variable::do_wait_until(boost::unique_lock<boost::mutex>&, timespec const&) ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#2  0x00007ffff75484ba in boost::this_thread::hiden::sleep_for(timespec const&) () from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#3  0x0000555555709924 in sleep_for (ns=<synthetic pointer>)
    at /usr/include/boost/thread/pthread/thread_data.hpp:235
#4  boost::this_thread::sleep_for<long, boost::ratio<1l, 1000l> > (d=...)
    at /usr/include/boost/thread/v2/thread.hpp:53
#5  0x0000555555714773 in MilliSleep (n=120000) at util.h:97
#6  ThreadOpenAddedConnections () at net.cpp:1438
#7  0x000055555571e373 in TraceThread<void (*)()> (
    name=0x555555b37ff1 "addcon", 
    func=0x555555713f80 <ThreadOpenAddedConnections()>) at util.h:576
#8  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#9  0x00007ffff58c9182 in start_thread (arg=0x7fffa37ae700)
    at pthread_create.c:312
#10 0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 15 (Thread 0x7fffa3fff700 (LWP 6492)):
#0  0x00007ffff43d0c33 in select () at ../sysdeps/unix/syscall-template.S:81
#1  0x0000555555715b6e in ThreadSocketHandler () at net.cpp:896
#2  0x000055555571e373 in TraceThread<void (*)()> (name=0x555555b06813 "net", 
    func=0x5555557151e0 <ThreadSocketHandler()>) at util.h:576
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffa3fff700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 11 (Thread 0x7fffbd1b4700 (LWP 6471)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x00005555556f7033 in wait (m=..., 
    this=0x555555ebcce8 <scriptcheckqueue+40>)
    at /usr/include/boost/thread/pthread/condition_variable.hpp:73
#2  CCheckQueue<CScriptCheck>::Loop (this=0x555555ebccc0 <scriptcheckqueue>, 
    fMaster=false) at checkqueue.h:95
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffbd1b4700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 10 (Thread 0x7fffbda05700 (LWP 6470)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x00005555556f7033 in wait (m=..., 
    this=0x555555ebcce8 <scriptcheckqueue+40>)
    at /usr/include/boost/thread/pthread/condition_variable.hpp:73
#2  CCheckQueue<CScriptCheck>::Loop (this=0x555555ebccc0 <scriptcheckqueue>, 
    fMaster=false) at checkqueue.h:95
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffbda05700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 9 (Thread 0x7fffe2710700 (LWP 6469)):
#0  pthread_cond_wait@@GLIBC_2.3.2 ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S:185
#1  0x00005555556f7033 in wait (m=..., 
    this=0x555555ebcce8 <scriptcheckqueue+40>)
    at /usr/include/boost/thread/pthread/condition_variable.hpp:73
#2  CCheckQueue<CScriptCheck>::Loop (this=0x555555ebccc0 <scriptcheckqueue>, 
    fMaster=false) at checkqueue.h:95
#3  0x00007ffff7547a4a in ?? ()
   from /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.54.0
#4  0x00007ffff58c9182 in start_thread (arg=0x7fffe2710700)
    at pthread_create.c:312
#5  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 8 (Thread 0x7fffcf2dd700 (LWP 6463)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff62067be in QEventDispatcherGlib::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#4  0x00007ffff61d80af in QEventLoop::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#5  0x00007ffff61d83a5 in QEventLoop::exec(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#6  0x00007ffff60d4c5f in QThread::exec() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#7  0x00007ffff60d732f in ?? () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#8  0x00007ffff58c9182 in start_thread (arg=0x7fffcf2dd700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 7 (Thread 0x7fffe1ebf700 (LWP 6462)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff62067a1 in QEventDispatcherGlib::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#4  0x00007ffff61d80af in QEventLoop::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#5  0x00007ffff61d83a5 in QEventLoop::exec(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#6  0x00007ffff60d4c5f in QThread::exec() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#7  0x00007ffff60d732f in ?? () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#8  0x00007ffff58c9182 in start_thread (arg=0x7fffe1ebf700)
    at pthread_create.c:312
#9  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 4 (Thread 0x7fffe37b2700 (LWP 6458)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007ffff39c3129 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#4  0x00007ffff39e7f15 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff58c9182 in start_thread (arg=0x7fffe37b2700)
    at pthread_create.c:312
#6  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 3 (Thread 0x7fffe95de700 (LWP 6457)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c330a in g_main_loop_run ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007fffed561e16 in ?? () from /usr/lib/x86_64-linux-gnu/libgio-2.0.so.0
#4  0x00007ffff39e7f15 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff58c9182 in start_thread (arg=0x7fffe95de700)
    at pthread_create.c:312
#6  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 2 (Thread 0x7fffe9e2f700 (LWP 6456)):
#0  0x00007ffff43cbfbd in poll () at ../sysdeps/unix/syscall-template.S:81
#1  0x00007ffff39c2fe4 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#2  0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#3  0x00007fffe9e371ad in ?? ()
   from /usr/lib/x86_64-linux-gnu/gio/modules/libdconfsettings.so
#4  0x00007ffff39e7f15 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#5  0x00007ffff58c9182 in start_thread (arg=0x7fffe9e2f700)
    at pthread_create.c:312
#6  0x00007ffff43d930d in clone ()
    at ../sysdeps/unix/sysv/linux/x86_64/clone.S:111

Thread 1 (Thread 0x7ffff7fc77c0 (LWP 6454)):
#0  __lll_lock_wait ()
    at ../nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S:135
#1  0x00007ffff58cb672 in _L_lock_953 ()
   from /lib/x86_64-linux-gnu/libpthread.so.0
#2  0x00007ffff58cb4da in __GI___pthread_mutex_lock (
    mutex=0x555555ebcb80 <cs_main>) at ../nptl/pthread_mutex_lock.c:114
#3  0x0000555555664d54 in lock (this=<optimized out>)
    at /usr/include/boost/thread/pthread/recursive_mutex.hpp:110
#4  lock (this=<optimized out>) at ../../src/sync.h:66
#5  lock (this=<synthetic pointer>)
    at /usr/include/boost/thread/lock_types.hpp:346
#6  Enter (pszName=<optimized out>, pszFile=<optimized out>, 
    nLine=<optimized out>, this=<synthetic pointer>) at ../../src/sync.h:118
#7  CMutexLock (fTry=false, nLine=196, 
    pszFile=0x555555afb29d "transactiontablemodel.cpp", 
    pszName=<optimized out>, mutexIn=..., this=<synthetic pointer>)
    at ../../src/sync.h:139
#8  TransactionTablePriv::index (this=0x555556729f20, idx=idx@entry=40217)
    at transactiontablemodel.cpp:196
#9  0x0000555555663a70 in TransactionTableModel::index (this=0x555556852420, 
    row=40217, column=0, parent=...) at transactiontablemodel.cpp:615
#10 0x0000555555660d5d in TransactionFilterProxy::filterAcceptsRow (
    this=0x555557aa5960, sourceRow=40217, sourceParent=...)
    at transactionfilterproxy.cpp:33
#11 0x00007ffff6fccfd6 in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#12 0x00007ffff6fcd1cf in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#13 0x00007ffff61ed87a in QMetaObject::activate(QObject*, QMetaObject const*, int, void**) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#14 0x00007ffff6237664 in QAbstractItemModel::rowsInserted(QModelIndex const&, int, int) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#15 0x00007ffff61d35ce in QAbstractItemModel::endInsertRows() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#16 0x00005555556659fc in TransactionTablePriv::updateWallet (
    this=0x555556729f20, hash=..., status=status@entry=0)
    at transactiontablemodel.cpp:156
#17 0x000055555566405d in TransactionTableModel::updateTransaction (
    this=0x555556852420, hash=..., status=0) at transactiontablemodel.cpp:255
#18 0x0000555555614566 in WalletModel::updateTransaction (
    this=this@entry=0x555556226790, hash=..., status=<optimized out>)
    at walletmodel.cpp:127
#19 0x000055555562cfdc in WalletModel::qt_static_metacall (_o=0x555556226790, 
    _c=<optimized out>, _id=<optimized out>, _a=0x7fff9158d220)
    at moc_walletmodel.cpp:80
#20 0x00007ffff61f1c1e in QObject::event(QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#21 0x00007ffff6a52e2c in QApplicationPrivate::notify_helper(QObject*, QEvent*) () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#22 0x00007ffff6a594a0 in QApplication::notify(QObject*, QEvent*) ()
   from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#23 0x00007ffff61d94dd in QCoreApplication::notifyInternal(QObject*, QEvent*)
    () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#24 0x00007ffff61dcb3d in QCoreApplicationPrivate::sendPostedEvents(QObject*, int, QThreadData*) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#25 0x00007ffff6206f83 in ?? () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#26 0x00007ffff39c2e04 in g_main_context_dispatch ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#27 0x00007ffff39c3048 in ?? () from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#28 0x00007ffff39c30ec in g_main_context_iteration ()
   from /lib/x86_64-linux-gnu/libglib-2.0.so.0
#29 0x00007ffff62067a1 in QEventDispatcherGlib::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#30 0x00007ffff6af4bb6 in ?? () from /usr/lib/x86_64-linux-gnu/libQtGui.so.4
#31 0x00007ffff61d80af in QEventLoop::processEvents(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#32 0x00007ffff61d83a5 in QEventLoop::exec(QFlags<QEventLoop::ProcessEventsFlag>) () from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#33 0x00007ffff61ddb79 in QCoreApplication::exec() ()
   from /usr/lib/x86_64-linux-gnu/libQtCore.so.4
#34 0x00005555555b47e9 in main (argc=1, argv=<optimized out>)
    at bitcoin.cpp:580
(gdb) 
```
 

comment number: 41209569 
body: Looking at just thread 1 it again seems the same problem. Would be interesting to see if DEBUG_LOCKORDER turns something up.
 

comment number: 41210392 
body: It does:

```
2014-04-23 20:26:40 UpdateTip: new best=00000000000000002f4c09eee4cd30bb305bc28e048e8b0a4afd0ebb6ced16a7  height=297363  log2_work=78.174438  tx=37418866  date=2014-04-23 20:10:17 progress=0.999947
2014-04-23 20:26:40 AddToWallet 838a56f87e9bb3f8690b19268b3d83dd7311cc53858e5c10bb683416ee6cbfc8  
2014-04-23 20:26:40 ProcessBlock: ACCEPTED
2014-04-23 20:27:05 POTENTIAL DEADLOCK DETECTED
2014-04-23 20:27:05 Previous lock order was:
2014-04-23 20:27:05  (1) wallet->cs_wallet  transactiontablemodel.cpp:99
2014-04-23 20:27:05  (2) cs_main  transactiontablemodel.cpp:196
2014-04-23 20:27:05 Current lock order is:
2014-04-23 20:27:05  (2) cs_main  wallet.cpp:837
2014-04-23 20:27:05  (1) cs_wallet  wallet.cpp:837
```
 

comment number: 41210557 
body: For the record, that is commit b45e335db "Solve chainActive-related locking issues"
 

comment number: 41211098 
body: It happened again on the very next block:

```
2014-04-23 20:32:21 UpdateTip: new best=00000000000000005715cefa23772ecb945ac63695f48dc87bc7dcb529803e7d  height=297364  log2_work=78.174564  tx=37419550  date=2014-04-23 20:27:50 progress=0.999986
2014-04-23 20:32:21 AddToWallet 5718101a513ba18d902f7a543590edd82dc0e0bd61d7327c2c16bd3a5544c913  
2014-04-23 20:32:21 AddToWallet 1db71fe7dc58cef500d5c4ecef1e849618cf135ed05fe7f0158326643f38180a  
2014-04-23 20:32:21 AddToWallet 934c59fcfacd33bd9fecd85b849c1933fc03784762b12abb2f13476e27ff8a5d  
2014-04-23 20:32:21 ProcessBlock: ACCEPTED
2014-04-23 20:32:27 receive version message: /[...]
2014-04-23 20:32:27 Added time data, samples 4, offset -1 (+0 minutes)
2014-04-23 20:32:43 POTENTIAL DEADLOCK DETECTED
2014-04-23 20:32:43 Previous lock order was:
2014-04-23 20:32:43  (1) wallet->cs_wallet  transactiontablemodel.cpp:99
2014-04-23 20:32:43  (2) cs_main  transactiontablemodel.cpp:196
2014-04-23 20:32:43 Current lock order is:
2014-04-23 20:32:43  (2) cs_main  wallet.cpp:837
2014-04-23 20:32:43  (1) cs_wallet  wallet.cpp:837
```
 

comment number: 41211486 
body: Argh, seems that you have an earlier revision of that pull, not the one that was merged into master (which is 55a1db4). We're debugging a problem that was solved even before pulling it into master.
Let's just update to master HEAD.
 

comment number: 41214577 
body: I started it again.  This time I see a bunch of warnings but it hasn't locked up yet:

```
2014-04-23 20:46:19 Added time data, samples 5, offset -1 (+0 minutes)
2014-04-23 20:46:19 nTimeOffset = +0  (+0 minutes)
2014-04-23 20:46:53 receive version message: /[...]
2014-04-23 20:46:53 Added time data, samples 6, offset -2 (+0 minutes)
2014-04-23 20:46:53 POTENTIAL DEADLOCK DETECTED
2014-04-23 20:46:53 Previous lock order was:
2014-04-23 20:46:53  pnode->cs_vRecvMsg  net.cpp:1541
2014-04-23 20:46:53  (1) cs_main  main.cpp:3245
2014-04-23 20:46:53  cs_mapRelay  main.cpp:3325
2014-04-23 20:46:53  (2) cs_vSend  net.h:449
2014-04-23 20:46:53 Current lock order is:
2014-04-23 20:46:53  (2) pnode->cs_vSend  net.cpp:1560
2014-04-23 20:46:53  (1) cs_main  main.cpp:4205
2014-04-23 20:46:53  (1) cs_main  main.cpp:1313
2014-04-23 20:46:59 POTENTIAL DEADLOCK DETECTED
2014-04-23 20:46:59 Previous lock order was:
2014-04-23 20:46:59  pnode->cs_vRecvMsg  net.cpp:1541
2014-04-23 20:46:59  (1) cs_main  main.cpp:3245
2014-04-23 20:46:59  cs_mapRelay  main.cpp:3325
2014-04-23 20:46:59  (2) cs_vSend  net.h:449
2014-04-23 20:46:59 Current lock order is:
2014-04-23 20:46:59  (2) pnode->cs_vSend  net.cpp:1560
2014-04-23 20:46:59  (1) cs_main  main.cpp:4205
2014-04-23 20:46:59  (1) cs_main  main.cpp:1313
2014-04-23 20:47:06 receive version message: /[...]
2014-04-23 20:47:06 Added time data, samples 7, offset +0 (+0 minutes)
2014-04-23 20:47:06 nTimeOffset = +0  (+0 minutes)
2014-04-23 20:47:22 POTENTIAL DEADLOCK DETECTED
2014-04-23 20:47:22 Previous lock order was:
2014-04-23 20:47:22  pnode->cs_vRecvMsg  net.cpp:1541
2014-04-23 20:47:22  (1) cs_main  main.cpp:3245
2014-04-23 20:47:22  cs_mapRelay  main.cpp:3325
2014-04-23 20:47:22  (2) cs_vSend  net.h:449
2014-04-23 20:47:22 Current lock order is:
2014-04-23 20:47:22  (2) pnode->cs_vSend  net.cpp:1560
2014-04-23 20:47:22  (1) cs_main  main.cpp:4205
2014-04-23 20:47:22  (1) cs_main  main.cpp:1313
2014-04-23 20:47:43 receive version message: /[...]
2014-04-23 20:47:43 Added time data, samples 8, offset -1 (+0 minutes)
2014-04-23 20:47:47 receive version message: /[...]
2014-04-23 20:47:47 Added time data, samples 9, offset +0 (+0 minutes)
2014-04-23 20:47:47 nTimeOffset = +0  (+0 minutes)
2014-04-23 20:48:26 POTENTIAL DEADLOCK DETECTED
2014-04-23 20:48:26 Previous lock order was:
2014-04-23 20:48:26  pnode->cs_vRecvMsg  net.cpp:1541
2014-04-23 20:48:26  (1) cs_main  main.cpp:3245
2014-04-23 20:48:26  cs_mapRelay  main.cpp:3325
2014-04-23 20:48:26  (2) cs_vSend  net.h:449
2014-04-23 20:48:26 Current lock order is:
2014-04-23 20:48:26  (2) pnode->cs_vSend  net.cpp:1560
2014-04-23 20:48:26  (1) cs_main  main.cpp:4205
2014-04-23 20:48:26  (1) cs_main  main.cpp:1313
2014-04-23 20:52:01 POTENTIAL DEADLOCK DETECTED
2014-04-23 20:52:01 Previous lock order was:
2014-04-23 20:52:01  pnode->cs_vRecvMsg  net.cpp:1541
2014-04-23 20:52:01  (1) cs_main  main.cpp:3245
2014-04-23 20:52:01  cs_mapRelay  main.cpp:3325
2014-04-23 20:52:01  (2) cs_vSend  net.h:449
2014-04-23 20:52:01 Current lock order is:
2014-04-23 20:52:01  (2) pnode->cs_vSend  net.cpp:1560
2014-04-23 20:52:01  (1) cs_main  main.cpp:4205
2014-04-23 20:52:01  (1) cs_main  main.cpp:1313
2014-04-23 20:55:26 POTENTIAL DEADLOCK DETECTED
2014-04-23 20:55:26 Previous lock order was:
2014-04-23 20:55:26  pnode->cs_vRecvMsg  net.cpp:1541
2014-04-23 20:55:26  (1) cs_main  main.cpp:3245
2014-04-23 20:55:26  cs_mapRelay  main.cpp:3325
2014-04-23 20:55:26  (2) cs_vSend  net.h:449
2014-04-23 20:55:26 Current lock order is:
2014-04-23 20:55:26  (2) pnode->cs_vSend  net.cpp:1560
2014-04-23 20:55:26  (1) cs_main  main.cpp:4205
2014-04-23 20:55:26  (1) cs_main  main.cpp:1313
2014-04-23 21:03:45 POTENTIAL DEADLOCK DETECTED
2014-04-23 21:03:45 Previous lock order was:
2014-04-23 21:03:45  pnode->cs_vRecvMsg  net.cpp:1541
2014-04-23 21:03:45  (1) cs_main  main.cpp:3245
2014-04-23 21:03:45  cs_mapRelay  main.cpp:3325
2014-04-23 21:03:45  (2) cs_vSend  net.h:449
2014-04-23 21:03:45 Current lock order is:
2014-04-23 21:03:45  (2) pnode->cs_vSend  net.cpp:1560
2014-04-23 21:03:45  (1) cs_main  main.cpp:4205
2014-04-23 21:03:45  (1) cs_main  main.cpp:1313
```
 

comment number: 41220141 
body: OK, I rebuilt from HEAD, and haven't seen it hang since.  I still get warnings like these:

```
2014-04-23 21:52:39 Added time data, samples 8, offset +0 (+0 minutes)
2014-04-23 21:52:56 POTENTIAL DEADLOCK DETECTED
2014-04-23 21:52:56 Previous lock order was:
2014-04-23 21:52:56  pnode->cs_vRecvMsg  net.cpp:1537
2014-04-23 21:52:56  (1) cs_main  main.cpp:3246
2014-04-23 21:52:56  cs_mapRelay  main.cpp:3326
2014-04-23 21:52:56  (2) cs_vSend  net.h:449
2014-04-23 21:52:56 Current lock order is:
2014-04-23 21:52:56  (2) pnode->cs_vSend  net.cpp:1556
2014-04-23 21:52:56  (1) cs_main  main.cpp:4206
2014-04-23 21:52:56  (1) cs_main  main.cpp:1313
2014-04-23 21:53:47 receive version message: /Satoshi:0.8.5/:
2014-04-23 21:53:47 Added time data, samples 9, offset +14 (+0 minutes)
2014-04-23 21:53:47 nTimeOffset = -2  (+0 minutes)
2014-04-23 21:56:50 POTENTIAL DEADLOCK DETECTED
2014-04-23 21:56:50 Previous lock order was:
2014-04-23 21:56:50  pnode->cs_vRecvMsg  net.cpp:1537
2014-04-23 21:56:50  (1) cs_main  main.cpp:3246
2014-04-23 21:56:50  cs_mapRelay  main.cpp:3326
2014-04-23 21:56:50  (2) cs_vSend  net.h:449
2014-04-23 21:56:50 Current lock order is:
2014-04-23 21:56:50  (2) pnode->cs_vSend  net.cpp:1556
2014-04-23 21:56:50  (1) cs_main  main.cpp:4206
2014-04-23 21:56:50  (1) cs_main  main.cpp:1313
2014-04-23 21:56:51 POTENTIAL DEADLOCK DETECTED
2014-04-23 21:56:51 Previous lock order was:
2014-04-23 21:56:51  pnode->cs_vRecvMsg  net.cpp:1537
2014-04-23 21:56:51  (1) cs_main  main.cpp:3246
2014-04-23 21:56:51  cs_mapRelay  main.cpp:3326
2014-04-23 21:56:51  (2) cs_vSend  net.h:449
2014-04-23 21:56:51 Current lock order is:
2014-04-23 21:56:51  (2) pnode->cs_vSend  net.cpp:1556
2014-04-23 21:56:51  (1) cs_main  main.cpp:4206
2014-04-23 21:56:51  (1) cs_main  main.cpp:1313
2014-04-23 21:57:06 ERROR: CheckTransaction() : vin empty
2014-04-23 21:57:06 ERROR: AcceptToMemoryPool: : CheckTransaction failed
2014-04-23 21:57:06 POTENTIAL DEADLOCK DETECTED
2014-04-23 21:57:06 Previous lock order was:
2014-04-23 21:57:06  pnode->cs_vRecvMsg  net.cpp:1537
2014-04-23 21:57:06  (1) cs_main  main.cpp:3718
2014-04-23 21:57:06  (2) cs_vSend  net.h:449
2014-04-23 21:57:06 Current lock order is:
2014-04-23 21:57:06  (2) pnode->cs_vSend  net.cpp:1556
2014-04-23 21:57:06  (1) cs_main  main.cpp:4206
2014-04-23 21:57:06  (1) cs_main  main.cpp:1313
```
 

218. bug report number : ['3968']
comment number: 38907485 
body: So it appears that there is a leak of file descriptors somewhere in the RPC code?

What version of boost?
 

comment number: 38938231 
body: `1.53.0`
 

comment number: 39058013 
body: Are you using SSL?
 

comment number: 39107541 
body: Nope
 

comment number: 39175445 
body: Maybe doing anything else that may make your RPC usage behaviour different from others?

What do you mean by RPC requests 'getting interrupted'?
 

comment number: 39202572 
body: As in if a program crashes, or yje network is disconnected while a client
is making an RPC call. Only tested for remote connections
On Apr 1, 2014 12:47 AM, "Wladimir J. van der Laan" <
notifications@github.com> wrote:

> Maybe doing anything else that may make your RPC usage behaviour different
> from others?
> 
> What do you mean by RPC requests 'getting interrupted'?
> 
> ## 
> 
> Reply to this email directly or view it on GitHubhttps://github.com/bitcoin/bitcoin/issues/3968#issuecomment-39175445
> .
 

comment number: 39203297 
body: This would be a good candidate for a regression test in qa/rpc-tests.
You should be able to reproduce with kill -9 while servicing requests...
 

comment number: 42344742 
body: Hmm... So I attempted to reproduce this one in 0.9.0 on Linux/x64 with boost 1.53 by writing a script that banged on the RPC server pretty heavily with random SIGKILLs to interrupt the requests.  I got lots of CLOSE_WAITS, but they all seemed to clean themselves up and the server never stopped servicing requests.  However, it would get pretty backed up response time wise when I would bang really hard.  I'm starting to think that perhaps the server is getting wedged in a way that is specific to your chosen RPC requests.

Can you provide some more detail on what your RPC request activity looks like?  What functions are you calling and with what frequency are you calling them?  Even better, would you be willing to run with "-debug=rpc" and attach the debug.log file from the data directory?

Incidentally, rpctimeout was deprecated in 0.7.0 when multithreaded JSON-RPC was implemented.  The manpage for bitcoind erroneously still mentions it.
 

comment number: 52601008 
body: Please do not +1 issues. Only post if you have something substantial to add.
 

comment number: 83103381 
body: I was experiencing similar issues, where if hammering the RPC with requests as fast as possible (from a single threaded client process) it would at some point get stuck and hit the client side timeout (60s), after a while it get's unstuck and I can do a big batch of requests again.  
- Client process is PHP CURL (or HHVM, same result)
- Also experienced the same issue when hammering the `0.10` rest interface.  
- Could not see anything suspicious in the `lsof`, so I'm not sure if it's the same issue.  
- Nothing special in the `debug.log`, with `-debug` or `debug=rpc`.  

I could not reproduce it with a simple `while [ True ]; do bitcoin-cli -testnet getrawtransaction 1030c244faabd45f6750d7c7254fa1aa87158deb900a329ef50a6dcb3aa0228e; done`, nor with `while [ True ]; do curl http://localhost:18332/rest/tx/1030c244faabd45f6750d7c7254fa1aa87158deb900a329ef50a6dcb3aa0228e.hex; done;`

I managed to fix the issue by adding a `Connection: close` header to the client CURL request, after that I can hammer it for hours without interuptions.  
Or alternatively reuse the connection handler.

@espringe what are you using to do the requests and can you reproduce the RPC getting stuck by doing an infinite loop for `getrawtransaction 1030c244faabd45f6750d7c7254fa1aa87158deb900a329ef50a6dcb3aa0228e`?  
If so, can you try adding the `Connection: close` header and see if that fixes it for you?
 

comment number: 91820275 
body: Since 0.10, rpc keepalive is optional and off by default (in 0.8 and 0.9 it was always on). Does that resolve the issue?
 

comment number: 152208066 
body: This is likely the same as #6454 and fixed by #5677 
 

219. bug report number : ['3966']
comment number: 38790032 
body: After a minute it finally really quit:

```
2014-03-27 11:01:33 UpdateTip: new best=000000000c540716cb66222d5ed90de88bbddbe812b83d15d7527c835b2a5e14  height=208174  log2_work=58.298491  tx=1333404  date=2014-03-27 11:21:16 progress=1.000003
2014-03-27 11:01:33 ProcessBlock: ACCEPTED
2014-03-27 11:01:33 msghand thread interrupt
2014-03-27 11:01:33 Shutdown : In progress...
2014-03-27 11:01:33 StopNode()
2014-03-27 11:01:34 Shutdown : done
2014-03-27 11:01:34 Shutdown finished
2014-03-27 11:01:34 Shutdown result: 1
2014-03-27 11:01:34 Stopping thread
2014-03-27 11:01:34 Stopped thread
```
 

comment number: 39229095 
body: My guess is that it was in this loop: https://github.com/bitcoin/bitcoin/blob/master/src/main.cpp#L2086
Introduced in 75f51f2a63e0ebe34ab290c2b7141dd240b98c3b

Seemingly, disconnecting and connecting the new blocks can take quite a while. A boost::interruption_point() every so many blocks would solve this issue.

Just need a way to reproduce this...
 

comment number: 39231812 
body: If a large batch of orphans was received, and they just got connected (by receiving their missing parent link), you can end up with a very long (minutes...) lock on cs_main while that batch is being connected. I believe I mentioned that in the PR :)
 

comment number: 39658724 
body: I'll have a go at fixing this...
 

comment number: 54807125 
body: This hasn't been a problem for a long time.
 

220. bug report number : ['3957']
comment number: 42762608 
body: I have reproduced this issue in the latest master branch and can confirm the behaviour as described in the above report.

Step 1: renamed blk00000.dat to blk.00000.dat.moved
Step 2: Requested block 1 (getdata 000000006a625f06636b8bb6ac7b960a8d03705d1ace08b1a19da3fdcc99ddbd)
Step 3: Received a "block" response with a corrupt block: 020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
Messages logged in debug.log:
2014-05-11 05:20:35 Unable to open file /media/btcnode/blocks/blk00000.dat
2014-05-11 05:20:35 ERROR: ReadBlockFromDisk : OpenBlockFile failed

Both OpenBlockFile() and its calling function ReadBlockFromDisk() are correctly detecting the error, but the block-serving code in ProcessGetData() is not checking the return value for errors.

A simple solution is to check for the error and not respond to the getdata request if the block was not available on disk.

Pull request incoming.
 

comment number: 44716582 
body: This issue can be closed as it has been fixed.
 

221. bug report number : ['3943']
comment number: 39758572 
body: @luke-jr bitcoin_find_bdb48.m4 is your baby. Would you like to look into this? Otherwise I'm happy to track it down.
 

comment number: 39821614 
body: Based on a cursory glance looks like line 55-66 of bitcoin_find_bdb48.m4 might be the cause of the issue.

56: for searchlib in db_cxx-4.8 db_cxx;

if db_cxx found it stops there but there should be a validation on what option is selected.
 

comment number: 155742980 
body: Duplicate of #3921. Would still be nice to have explicit options to set the path to BDB, especially as the recommended version 4.8 is nowhere available as system version anymore.
 

222. bug report number : ['3916']
comment number: 38347435 
body: See #3935 (please help test).
 

comment number: 38664767 
body: Solved by #3935 which has been merged
 

223. bug report number : ['3913']
comment number: 38140445 
body: Are you sure you didn't just click the wrong button?
 

comment number: 38162926 
body: As confident as one can be.  I clicked, wrong action happened, profanity
ensued.

On Thu, Mar 20, 2014 at 12:14 AM, Wladimir J. van der Laan <
notifications@github.com> wrote:

> Are you sure you didn't just click the wrong button?
> 
> ## 
> 
> Reply to this email directly or view it on GitHubhttps://github.com/bitcoin/bitcoin/issues/3913#issuecomment-38140445
> .
 

comment number: 39043221 
body: If this can be reproduced, this it is a big problem. @patrickmason, try doing that same thing again (offline!) and then rollback your wallet afterwards. A video would be nice, plus any debug logs.
 

comment number: 57661222 
body: Can someone reproduce this? Or any other updates about this?
 

comment number: 57665084 
body: I have not been able to reproduce it, must have been human error.

On Thu, Oct 2, 2014 at 9:58 AM, lichtamberg notifications@github.com
wrote:

> Can someone reproduce this? Or any other updates about this?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/bitcoin/bitcoin/issues/3913#issuecomment-57661222.
 

comment number: 57691771 
body: I've also never been able to reproduce it. Without further evidence (or reports from other users) I'm going to close this.
 

